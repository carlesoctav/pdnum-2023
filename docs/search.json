[
  {
    "objectID": "module/week-02.html",
    "href": "module/week-02.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Dalam pemrograman, seringkali pengguna diminta memberi suatu input, entah suatu nilai, string, dll., ke program, lalu program tersebut akan menggunakan input tersebut sebagai nilai dari suatu variabel. Hal ini juga dapat dilakukan pada Octave. Untuk membuat Octave meminta input dari user, gunakan syntax input(prompt), dengan prompt adalah string yang berisi pesan dalam input.\n\n    A = input(\"Masukkan suatu angka:\")\n\nJika tidak ingin membuat pesan input, cukup isi “” sebagai prompt\n\n    A = input(\"\")\n\nPerlu diketahui bahwa input yang diberikan pengguna akan dievaluasi sebagai ekspresi. Jadi, bisa saja input yang diberikan akan dievaluasi sebagai kode Octave. Sebagai contoh, jika kita memasukkan operasi bilangan pada inpu ….\n\nB = input(\"Operasi bilangan: \")\n\n… , maka operasi tersebut akan dievaluasi dan memberikan hasil operasinya. Jika kita memasukkan kode Octave, seperti meng-assign suatu variabel …\n\nC = input(\"Assign variabel: \")\n\n…, maka nilai dari variabel yagn di-assign akan masuk ke variabel input …\n\nx\n\nsekaligus variabel yang di-assign di dalam input. Jika kalian ingin agar input yang dimasukkan tidak dievaluasi, input tersebut dapat diubah terlebih dahulu menjadi string.\n\n D = input(\"Masukkan suatu string: \")\n\n\ntypeinfo(D) % untuk menentukan tipe data variabel\n\nBisa juga dengan menambah argumen pada input() menjadi input(prompt, “s”). Jika menambahkan argumen, maka apapun input yang kalian masukkan akan menjadi string tanpa perlu menggunakan tanda petik.\n\nE = input(\"Masukkan suatu string: \", \"s\")\n\n\ntypeinfo(E)\n\nSelain menggunakan input(), kita juga bisa menggunakan syntax menu(title, op1, op2, …). Syntax tersebut akan memunculkan kotak dialog dengan judul title dan pilihan op1, op2, dst. (sesuai yang dimasukkan). Syntax ini sangat berguna untuk program-program interaktif karena mempunyai GUI sendiri.\n\nF = menu(\"Pilih salah satu\", \"Pilihan 1\", \"Pilihan 2\", \"Pilihan 3\")\n\nTergantung pilihan kalian, variabel yang mengandung menu() akan diisi bilangan dari 1 hingga n tergantung banyaknya pilihan.\nUntuk output, mungkin cukup untuk memanggil variabel itu sendiri, seperti…\n\nC\n\n…, namun kalian juga bisa hanya memunculkan nilai dari variabelnya tanpa sekaligus memunculkan variabel tersebut dengan menggunakan syntax disp(). Syntax ini digunakan jika yang di-output hanya suatu variabel atau string simpel, dll.\n\ndisp(C)\n\n\ndisp(\"Ini adalah string\")\n\nJika yang ingin dimunculkan adalah pesan yang membutuhkan banyak formatting, kalian bisa menggunakan syntax printf(). Syntax tersebut dapat melakukan formatting pesan agar dapat menerima variabel selain string.\n\nx=input(\"masukkan nilai x: \")\n\n\nprintf(\"Ini adalah string %d\", x)\n\nPada contoh di atas, kita ingin agar variabel x dapat di-output bersama dengan pesan string. Kita menggunakan %d agar nilai x dapat di-print sebagai bilangan desimal. Jika variabelnya berisi string, maka gunakan %s. Jika variabelnya berisi float, gunakan %f untuk print dalam bentuk desimal, atau %.nf untuk sekaligus mengatur angka di belakang koma sebanyak n.\n\nprintf(\"pi = %.3f\", pi)\n\nJika float tersebut ingin di-print dalam notasi saintifik, gunakan %e atau %E. Keduanya hanya berbeda di hasil output yang berupa E (besar) ataupun e (kecil).\n\nprintf(\"pi = %.3e\", pi)\n\nJika ingin print karakter persen itu sendiri (%), gunakan %%.\nJika ada lebih dari satu formatting di satu printf(), maka variabelnya juga harus dimasukkan secara berurutan.\n\nprintf(\"pi = %.3f dan e = %.3e\", pi, e)\n\n\n\n\nSeperti halnya bahas pemrograman, Octave pun juga memiliki conditional statements. Secara umum, conditional statement pada Octave berbentuk:\n\ncond\n  body\nendcond\n\nPada potongan kode di atas, cond adalah jenis conditional statement yagn digunakan, bisa berupa if, for, dan lainnya, body berisi kode yang dijalankan ketika cond terpenuhi, dan endcond adalah bagian penutup dari conditional statement, bisa berupa endif, endfor, dan lainnya tergantung cond apa yang digunakan.\nOperasi dasar yang digunakan pada conditional statements adalah operasi perbandingan, dimana pada dasarnya, dua atau lebih nilai dibandingkan dengan operator dan dicek apakah memenuhi atau tidak. Jika memenuhi, maka nilainya 1, dan jika tidak, maka nilainya 0. Ada 6 operator dasar untuk perbandingan:\n- sama dengan (==)\n- lebih dari (>)\n- kurang dari (<)\n- lebih dari atau sama dengan (>=)\n- kurang dari atau sama dengan (<=)\n- tidak sama dengan (!= atau ~=)\n\n2<3\n\n\n4==5\n\nSelain operator di atas, ada juga syntax untuk perbandingan:\n- isequal(a, b, c, ...) mengecek apakah a, b, dan c semuanya sama.\n- strcmp(s1, s2) mengecek apakah s1 dan s2 adalah string yang sama.\n- strncmp(s1, s2, n) mengecek apakah n karakter pertama pada s1 dan s2 sama.\n- strcmpi(s1, s2) mirip strcmp(), namun tidak case-sensitive.\n- strncmpi(s1, s2, n) mirip strncmp(), namun tidak case-sensitive.\n\nisequal(1, 3, 5)\n\n\nstrcmp(\"ayam\", \"Ayam\")\n\n\nstrcmpi(\"ayam\", \"Ayam\")\n\n\nstrncmp(\"sayamakan\", \"saya makan\", 4)\n\nBerikut beberapa jenis conditional statement pada Octave. Kode-kode ini akan ditulis di editor.\nIf adalah conditional statement dasar dalam decision-making melalui perbandingan nilai. If memiliki 3 bentuk. Bentuk pertama:\n\nif (cond)\n  body;\nendif\n\nBentuk ini adalah bentuk paling simpel dalam menggunakan if. Jika cond bernilai 1, maka body dieksekusi, dan sebaliknya. Contoh:\n\nx = input( \"Masukkan nilai x: \")\nif x > 0\n    printf(\"%d adalah bilangan positif.\\n\", x);\nendif\n\nBukanlah if jika tidak ada else. Untuk menggunakannya, cukup menyelipkan bagian else layaknya if sehingga menjadi:\n\nif (cond)\n  body1;\nelse\n  body2;\nendif\n\nContoh:\n\nx = input(\"Masukkan x: \");\nif mod(x, 2) == 0\n  printf(\"x genap.\\n\");\nelse\n  printf(\"x ganjil.\\n\");\nendif\n\nKita pun juga dapat membuat lebih dari 2 condition selain if dan else. Cukup tambahkan bagian elseif. Kita dapat menambahkan berapapun banyaknya elseif sesuka hati (dan komputer), selama bagian akhirnya adalah else.\n\nif (cond1)\n  body1;\nelseif (cond2)\n  body2;\nelse\n  body3;\nendif\n\nUntuk beberapa kasus, lebih jelas jika kita menggunakan model kode seperti di atas. Namun, terkadang kita ingin membuat program berjalan sesuai input, dan jika menggunakan if-else, kodenya akan terlihat jelek. Maka, kita juga bisa menggantinya dengan kode switch. Bentuk umum dari switch adalah:\n\nswitch (var)\n  case lab1\n    body1;\n  case lab2\n    body2;\n  otherwise\n    body3;\nendswitch\n\nPada kode di atas, var akan dicocokkan dengan lab1, lab2, dst. yang sesuai. Jika tidak ada yang sesuai, kode akan masuk ke bagian otherwise. Layaknya elseif, kita juga dapat menambahkan berapapun banyaknya case sesuka hati, selama terdapat paling tidak satu case (bahkan bagian otherwise opsional).\nContoh:\n\nmnu = input(\"Masukkan metode: \");\nswitch (mnu)\n  case 1\n    printf(\"Bisection.\\n\")\n  case 2\n    printf(\"Regula Falsi.\\n\")\n  otherwise\n    printf(\"Input tidak valid.\\n\")\nendswitch\n\nJika case berisi array, kode akan masuk case tersebut jika var sesuai dengan salah satu elemen di array tersebut.\n\nA = 7;\nswitch (A)\n  case {6, 7}\n    printf(\"A adalah 6 atau 7\");\n  otherwise\n    printf(\"A bukanlah 6 ataupun 7\");\nendswitch\n\nBentuk umum dari for adalah:\n\n\n\n\n\n\nfor var = expr\n  body;\nendfor\n\nBiasanya isi dari expr adalah a:b, yang menyebabkan var diiterasi dari a hingga b. Secara umum, for akan meng-assign tiap kolom pada expr ke var (bentuk range a:b secara umum adalah vektor baris, sehingga iterasi kolom pada a:b adalah dari a hingga b). Contoh:\n\nfib = ones(1, 10); % ones(1, 10) = matriks 1x10 berisi 1.\nfor i = 3: 10\n  fib(i) = fib(i-1) + fib(i-2);\nendfor\ndisp(fib)\n\nKarena iterasinya antar kolom, maka jika expr adalah suatu matriks, maka var akan diiterasi sebagai vektor kolom. Contoh:\n\nfor i = [1, 2, 3; 4, 5, 6; 7, 8, 9]\n  i\nendfor\n\nBentuk umum dari while adalah:\n\n\n\n\nwhile (cond)\n  body;\nendwhile\n\nSerupa dengan if, while akan menjalankan body jika cond bernilai taknol. Namun, akan diulang terus hingga cond bernilai nol, baru berhenti.\n\nfib = ones(1, 10);\ni = 3;\nwhile i <= 10\n  fib(i) = fib(i-1) + fib(i-2);\n  i++;\nendwhile\ndisp(fib)\n\nPada contoh di atas, penting untuk memasukkan bagian i++ agar suatu saat nilai i akan lebih dari 10. Hati-hati menggunakan while, karena dapat mengakibatkan infinite loop.\n\n\n\nBentuk umum dari do adalah:\n\ndo\n  body\nuntil (cond)\n\nSekilas, do terlihat serupa dengan while. Yang membedakannya adalah do akan terus menjalankan body ketika cond bernilai 0 dan berhenti ketika cond bernilai taknol. Kondisi cond pada do juga berada di akhir, sehingga body pasti akan dijalankan paling tidak sekali. Perbedaan kecil selanjutnya adalah do tidak memakai enddo seperti layaknya endif, endwhile, dan sejenisnya.\n\nfib = ones(1, 10);\ni = 2;\ndo\n  i++;\n  fib(i) = fib(i-1) + fib(i-2);\nuntil i == 10\ndisp(fib)\n\n\n\n\nbreak dan continue adalah dua statement yang digunakan dan hanya digunakan dalam loop. Statement break akan langsung mengeluarkan program dari loop, sedangkan continue akan langsung menuju iterasi selanjutnya tanpa menyelesaikan sisa kode pada badan loop.\nContoh perbedaan break dan continue:\n\na = [];\nfor i = 1:10\n  if mod(i, 5) == 0\n    break;\n  endif\n  a = [a, i];\nendfor\ndisp(a)\n\n\na = [];\nfor i = 1:10\n  if mod(i, 5) == 0\n    continue;\n  endif\n  a = [a, i];\nendfor\ndisp(a)\n\n\n\n\nSebelum kita lanjutkan, kita harus terlebih dahulu mengetahui tentang function file dan script file.\nFunction file adalah file yang dapat digunakan oleh Octave untuk memanggil fungsi yang telah didefinisikan di dalamnya. Function file ini berguna jika kalian ingin menggunakan fungsi tersebut secara berkala.\nScript file adalah file yang berisi kumpulan perintah Octave, layaknya script pemrograman. Script file berguna untuk pemrograman dan menjalankan/menyimpan suatu urutan perintah, sehingga bisa dijalankan kembali nantinya. Untuk selanjutnya, script file akan disebut “program”.\nPermasalahannya, kedua jenis file tersebut mempunyai ekstensi yang serupa (.m), namun function file tidak dapat dijalankan layaknya program.\nMisal kita mempunyai fungsi yang ingin disimpan dalam program bernama testfile.m (untuk sekarang kita akan abaikan dulu maksud dari tiap bagian dari fungsi ini. Intinya fungsi ini akan menampilkan variabel message yang kita masukkan.\n\nfunction test(message)\n  printf(\"%s\\n\", message);\nendfunction\n\ntest(\"AyatoBoba\");\n\nJika program tersebut dijalankan, akan muncul pesan peringatan…\nwarning: function name 'test' does not agree with function filename...\n…dan mungkin saja akan diikuti error lain. Jika kalian ingin membuat program, jangan gunakan function di line pertama yang dieksekusi.\nSekarang kita modifikasi testfile.m di atas.\n\n1;\nfunction test(message)\n  printf(\"%s\\n\", message);\nendfunction\n\ntest(\"AyatoBoba\");\n\nDi sini, kita menambahkan line yang tidak berpengaruh apa-apa dalam program kita sebelum line pendefinisian fungsi. Untuk membedakan function file dengan program, Octave mengecek perintah pertama yang dieksekusi. Jika perintah tersebut adalah pendefinisian fungsi, maka file tersebut akan dianggap sebagai function file, dan jika bukan, maka file tersebut akan dianggap sebagai program.\nSekarang kita masuk ke fungsi, pendefinisian, dan embel-embelnya. Fungsi adalah suatu bagian dari program yang nantinya akan dipanggil. Fungsi sangat berguna jika bagian program\ntersebut nantinya akan digunakan berkali-kali. Fungsi juga berguna agar pengorganisasian kode program lebih bagus. Syntax untuk pendefinisian fungsi adalah:\nfunction name body endfunction ```\nPotongan kode di atas akan membuat fungsi name dengan body adalah isi dari fungsi tersebut. Untuk memanggil fungsi tersebut, cukup dengan memanggil name. Contoh:\n\nfunction bangun\n  printf(\"BANGUN!!!!!\\n\");\nendfunction\n\nbangun;\n\nPada kedua contoh di atas, fungsinya tidak benar-benar memberikan suatu value, melainkan hanya sekedar output. Dalam kebanyakan kasus, kita menggunakan fungsi agar bisa mendapatkan suatu nilai yang dapat di-assign ke suatu variabel. Agar kita bisa mendapatkan value, maka kita harus meng-assign variabel untuk return. Strukturnya menjadi:\n\nfunction retval = name (args)\n  body\nendfunction\n\nretval adalah variabel lokal (namanya tidak harus retval) yang akan digunakan sebagai return value sehingga dapat di-assign. retval bisa berupa variabel, jika kita ingin me-return satu value, ataupun bisa berupa list dari variabel jika ingin me-return lebih dari satu value. Contoh return satu nilai:\n\nfunction x = quadratic(a)\n  x = a^2;\nendfunction\n\ny = quadratic(2);\ndisp(y);\n\ncontoh return lebih dari satu nilai:\n\nfunction [am, gm] = AMGM(v)\n  am = sum(v) / length(v);\n  gm = nthroot(prod(v), length(v));\nendfunction\n\n\nV = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n[amean, gmean] = AMGM(V);\nprintf(\"Arithmetic mean of %s is %g\\n\", mat2str(V), amean);\nprintf(\"Geometric mean of %s is %g\\n\", mat2str(V), gmean);\n\nOctave juga mempunyai syntax return sendiri. Namun, return pada Octave tidak digunakan untuk me-return suatu value, melainkan untuk keluar dari fungsi (serupa dengan break pada loop).\n\n\n\n\nKak ojan: untuk module tahun lalu-nya :D."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "D:"
  },
  {
    "objectID": "draft/week-03.html",
    "href": "draft/week-03.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Metode-metode sebelumnya, seperi Euler, Runge-Kutta, dan kawan-kawannya adalah metode jenis one-step, karena kita hanya menggunakan informasi dari satu nilai \\(t_{i}\\). Pada modul berikut akan dijelaskan mengenai metode multistep, dimana kita menggunakan lebih dari satu nilai \\(t_{i}\\) untuk membuat aproksimasi.\nTerdapat dua jenis metode multistep, yaitu:\n\nMultistep eksplisit, dimana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai \\(t\\) sebelumnya.\nMultistep implisit, dimana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai pada \\(t\\) sebelumnya, sekaligus nilai pada \\(t_{i+1}\\) itu sendiri.\n\nUntuk bagian awal, kita hanya akan menggunakan multistep eksplisit, dan multistep implisit akan dijelaskan kemudian menggunakan cara lain.\n\n\nMetode \\(n\\)-step Adams-Bashforth menggunakan \\(n\\) titik sebelumnya untuk mengaproksimasi nilai. Karena metode ini adalah metode multistep, maka \\(n\\) nilai awalnya pun harus diperoleh terlebih dahulu. Misal kita ingin menggunakan metode Adams-Bashforth orde 3 , maka \\(w_{1}, w_{2}\\), dan \\(w_{3}\\) harus ada terlebih dahulu sebelum dilanjutkan ke metode Adams-Bashforth. Nilai-nilai awal tersebut dapat diperoleh dari metode-metode one-step sebelumnya, seperti metode Runge-Kutta, yang akan kita gunakan.\nBerikut rumus untuk metode \\(n\\)-step Adams-Bashforth, masing-masing sesuai dengan jumlah step nya.\n\nTwo-step Adams Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{2}\\left[3 f\\left(t_{i}, w_{i}\\right)-f\\left(t_{i-1}, w_{i-1}\\right)\\right]\n\\end{gathered}\n\\]\n\nThree-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{12}\\left[23 f\\left(t_{i}, w_{i}\\right)-16 f\\left(t_{i-1}, w_{i-1}\\right)+5 f\\left(t_{i-2}, w_{i-2}\\right)\\right]\n\\end{gathered}\n\\]\n\nFour-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3} \\\\\nw_{i+1}=w_{i}+\\frac{h}{24}\\left[55 f\\left(t_{i}, w_{i}\\right)-59 f\\left(t_{i-1}, w_{i-1}\\right)+37 f\\left(t_{i-2}, w_{i-2}\\right)-9 f\\left(t_{i-3}, w_{i-3}\\right)\\right]\n\\end{gathered}\n\\]\n\nFive-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3}, \\quad w_{4}=\\alpha_{4}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{720}\\left[1901 f\\left(t_{i}, w_{i}\\right)-2774 f\\left(t_{i-1}, w_{i-1}\\right)+2616 f\\left(t_{i-2}, w_{i-2}\\right)\\right. \\\\\n\\left.-1274 f\\left(t_{i-3}, w_{i-3}\\right)+251 f\\left(t_{i-4}, w_{i-4}\\right)\\right]\n\\end{gathered}\n\\]\nprogram untuk two-step Adams-Bashforth:\n\nfunction [t, w] = adams2(f, a, b, n, alpha)\n  % Inisiasi variabel awal\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  \n  % Mencari t(2) dan w(2) menggunakan Runge-Kutta orde 4\n  i = 1;\n  t(i + 1) = t(i) + h;\n  m1 = h * f(t(i), w(i));\n  m2 = h * f(t(i) + (h/2), w(i) + (m1/2));\n  m3 = h * f(t(i) + (h/2), w(i) + (m2/2));\n  m4 = h * f(t(i + 1), w(i) + m3);\n  w(i+1) = w(i) + (m1 + 2*m2 + 2*m3 + m4) / 6;\n  \n  % Algoritma utama Adams-Bashforth\n  for i = 2:n\n    t(i + 1) = t(i) + h;\n    k1 = f(t(i), w(i));\n    k2 = f(t(i-1), w(i-1));\n    w(i+1) = w(i) + (h/2) * (3*k1 - k2);\n  endfor\nendfunction\n\n\n\n\nSerupa dengan metode adams-bashforth, bedanya persamaan iteratif \\(w_{i+1}\\) belum dalam bentuk yang dapat dihitung langsung (melainkan bentuknya implisit). Berikut ini adalah list persamaan iteratifnya (diambil dari buku burden).\n\nAdams-Moulton Two-Step Implicit Method \\[\n\\begin{aligned}\nw_0 & =\\alpha, \\quad w_1=\\alpha_1, \\\\\nw_{i+1} & =w_i+\\frac{h}{12}\\left[5 f\\left(t_{i+1}, w_{i+1}\\right)+8 f\\left(t_i, w_i\\right)-f\\left(t_{i-1}, w_{i-1}\\right)\\right],\n\\end{aligned}\n\\]\nAdams-Moulton Three-Step Implicit Method\n\n\\[\n\\begin{aligned}\nw_0 & =\\alpha, \\quad w_1=\\alpha_1, \\quad w_2=\\alpha_2, \\\\\nw_{i+1} & =w_i+\\frac{h}{24}\\left[9 f\\left(t_{i+1}, w_{i+1}\\right)+19 f\\left(t_i, w_i\\right)-5 f\\left(t_{i-1}, w_{i-1}\\right)+f\\left(t_{i-2}, w_{i-2}\\right)\\right],\n\\end{aligned}\n\\]\n\nAdams-Moulton Four-Step Implicit Method\n\n\\[\n\\begin{aligned}\nw_0= & \\alpha, \\quad w_1=\\alpha_1, \\quad w_2=\\alpha_2, \\quad w_3=\\alpha_3, \\\\\nw_{i+1}= & w_i+\\frac{h}{720}\\left[251 f\\left(t_{i+1}, w_{i+1}\\right)+646 f\\left(t_i, w_i\\right)\\right. \\\\\n& \\left.-264 f\\left(t_{i-1}, w_{i-1}\\right)+106 f\\left(t_{i-2}, w_{i-2}\\right)-19 f\\left(t_{i-3}, w_{i-3}\\right)\\right],\n\\end{aligned}\n\\]\nBentuk umum program yang akan dihasilkan\n\nfunction [t, w] = adam-moulton-general(f, a, b, n, alpha)\n  [\n    Inisialisai awal ...\n  ]\n  \n  [\n\n    Mencari nilai w_i lainnya yang dibutuhkan dengan rungge kutta jika \n    nilai awal tersebut tidak diberikan.\n  ]\n  \n  % Algoritma utama Adams-Bashforth\n\n\n  [\n    Iteratif algoritma adams-moulton\n\n    pada saat mencari $w_{i+1}$ gunakan metode numerik favorit anda.\n  ]\n\nendfunction\n\nTinjau bahwa, jika \\(f\\) linear, kita bisa mencarinya nilai bentuk explisit \\(W_{i+1}\\) dengan mudah. Dengan demikian, kita bisa mengganti metode numerik yang digunakan untuk mencari \\(w_{i+1}\\) dengan metode analitik.\n\n\n\nMenggunakan nilai \\(w_{i+1}\\) yang didapat secara implisit dari metode adams-moulton, kita masukkan ke dalam metode adams-bashforth untuk mengupdate nilai nilai \\(w_{i+1}\\) kembali.\nLihat contoh pada pada sub-chapter berikutnya.\n\n\n\n\n\n\n\nfunction [t,w] = rk4_sys(f, a, b, n, y0)\n  %f :differential equation y_p = f(t,y)\n  %a :initial time\n  %b :final time\n  %n :number of steps\n  %y0 :initial value\n\n  h=(b-a)/n;\n  t=[a:h:b];\n  s= length(y0);\n  w=zeros(s,n+1);\n  w(:,1)=y0;\n\n  for i=1:n\n    k1=f(t(i),w(:,i));\n    k2=f(t(i)+h/2,w(:,i)+h*k1/2);\n    k3=f(t(i)+h/2,w(:,i)+h*k2/2);\n    k4=f(t(i)+h,w(:,i)+h*k3);\n    w(:,i+1)=w(:,i)+h*(k1+2*k2+2*k3+k4)/6;\n\n\n\n\n\n% the multi-step second order method Adams-Bashforth-Moulton \n\n\nfunction [t,w] = abm2_sys(f,a,b,n,y0)\n  h=(b-a)/n;\n  t=[a:h:b];\n  s= length(y0);\n  w=zeros(s,n+1);\n  w(:,1)=y0;\n\n  w_serch= rk4_sys(f,a,b,n,y0);\n\n  w(:,2)= w_serch(:,2);\n\n  wnm1 = f(t(1),y0);\n  wn= f(t(2),y1);\n\n  for i=2:n\n    ws=w(:,i)+h/2*(3*wn-wnm1); % predictor\n    wnp1= f(t(i+1),ws); % predictor\n\n    w(:,i+1)=w(:,i)+h/2*(wn+wnp1); % corrector\n    wnm1=wn;\n    wn=f(t(i),w(:,i)); %corector"
  },
  {
    "objectID": "draft/week-02p2.html",
    "href": "draft/week-02p2.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Metode Euler metode paling dasar dalam mencari solusi dari permasalahan nilai awal dari suatu PD. Metode ini dikembangkan dari Teorema Taylor:\nMetode Euler metode paling dasar dalam mencari solusi dari permasalahan nilai awal dari suatu PD. Metode ini dikembangkan dari Teorema Taylor:\n\\[\ny\\left(t_{i+1}\\right)=y\\left(t_i\\right)+\\left(t_{i+1}-t_I\\right) y^{\\prime}\\left(t_i\\right)+\\cdots\n\\]\nMisalkan kita mempunyai suatu persamaan diferensial dengan nilai awal:\n\\[\n\\begin{gathered}\ny^{\\prime}=f(t, y), a \\leq t \\leq b \\\\\ny(a)=\\alpha\n\\end{gathered}\n\\]\nmaka solusi secara numeriknya adalah \\(w_i= y(t_i)\\), dengan:\n\\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+h f\\left(t_i, w_i\\right), \\quad i=1,2, \\ldots, n\n\\end{gathered}\n\\]\ndengan \\(n+1\\in \\mathbb{N}\\) menyatakan banyaknya titik nantinya.\nSolusi kita akan berupa titik yang nantinya dapat menggunakan interpolasi untuk nilai yang tidak dimuat di \\(w_i\\)\nAlgoritma untuk metode Euler adalah sebagai berikut:\n\nfunction [t, w] = euler(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    w(i + 1) = w(i) + h * m1;\n  endfor\nendfunction\n\nDisini, inputnya adalah: - \\(\\mathrm{f}=\\mathrm{E}(t, y)\\) merupakan suatu fungsi, - a dan b berturut-turut batas bawah dan batas atas dari \\(t\\) - \\(\\mathrm{n}\\) merupakan pembagi untuk step size dan \\(\\mathrm{n}+1\\) yang digunakan sebagai banyaknya titik, dan - alpha merupakan nilai awal Sekarang akan kita coba gunakan untuk menyelesaikan suatu PD. Misal diberikan PD sebagai berikut: \\[\n\\begin{aligned}\n& y^{\\prime}=y-t^2+1,0 \\leq t \\leq 2 \\\\\n& y(0)=0.5\n\\end{aligned}\n\\]\nmaka kita dapat mendefinisikan f=@(t, y)\\left(y-t^{\\wedge} 2+1\\right), a=0, b=2, dan alpha \\(=0.5\\) (@ disini menyatakan fungsi anonim yang cara kerjanya mirip dengan fungsi lambda pada Python), sehingga untuk \\(n=10\\), diperoleh kode sebagai berikut:\n\nf = @(t, y) (y – t^2 + 1);\na = 0;\nb = 2;\nn = 10;\n[t_euler, w_euler] = euler(f, a, b, n, alpha)\n\nUntuk visualisasinya, kita akan membuat plot dari hasil yang kita peroleh. Sebagai referensi, solusi eksak dari PD tersebut adalah \\(y(t)=(t+1)^2- 0.5 e^t\\)\nKita tambahkan kode berikut pada file:$\n\nsln = @(t) (t + 1)^2 - 0.5 * exp(t);\nfplot(sln, [0, 2], 'b');\nhold on;\nscatter(t_euler, w_euler, 'r');\nlegend('Solusi eksak', 'Metode Euler');\ntitle(‘Metode Euler’)\n\nSaat dijalankan, akan muncul jendela pop-up yang berisi plot yang telah dibuat.\n\n\n\ngambar pop up plot\n\n\nPenjelasan: * sln berisi fungsi referensi kita untuk di-plot dan dibandingkan. * fplot(f, [a, b]) akan menampilkan plot dari suatu fungsi f dengan domain [a, b]. Argumen tambahan ‘b’ memberi warna biru pada plot. * hold on akan menahan plot yang ada agar kita bisa menampilkan banyak plot sekaligus. * scatter(x, y) akan menampilkan x-y scatter plot. * legend memberi legenda pada plot yang telah dibuat. Legenda tersebut dimasukkan berurutan mulai dari plot yang didefinsikan terlebih dahulu * title memberi judul pada plot\n\n\n\n\nMetode midpoint \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} f\\left(t_i, w_i\\right)\\right)\n\\end{gathered}\n\\]\nMetode Euler modifikasi \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+\\frac{h}{2}\\left(f\\left(t_i, w_i\\right)+f\\left(t_{i+1}, w_i+h f\\left(t_i, w_i\\right)\\right)\\right)\n\\end{gathered}\n\\]\nMetode Heun (tidak umum digunakan) \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+\\frac{h}{4}\\left(f\\left(t_i, w_i\\right)+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} f\\left(t_i, w_i\\right)\\right)\\right)\\right)\n\\end{gathered}\n\\]\nMetode Runge-Kutta orde 4 \\[\n\\begin{aligned}\n& w_1=\\alpha \\\\\n& m_1=h f\\left(t_i, w_i\\right) \\\\\n& m_2=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{m_1}{2}\\right) \\\\\n& m_3=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{m_2}{2}\\right) \\\\\n& m_4=h f\\left(t_{i+1}, w_i+m_3\\right) \\\\\n& w_{i+1}=w_i+\\frac{m_1+2 m_2+2 m_3+m_4}{6}\n\\end{aligned}\n\\]\n\nBerikut adalah list algoritmanya.\n\nfunction [t, w] = midpoint(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 2), w(i) + (h / 2) * m1);\n    w(i + 1) = w(i) + h * m2;\n  endfor\nendfunction\n\n\nfunction [t, w] = euler(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i + 1), w(i) + h * m1);\n    w(i + 1) = w(i) + h * (m1 + m2) / 2;\n  endfor\nendfunction\n\n\nfunction [t, w] = heun(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 3), w(i) + (h / 3) * m1);\n    m3 = f(t(i) + (2 * h / 3), w(i) + (2 * h / 3) * m2);\n    m4 = m1 + 3 * m3;\n    w(i + 1) = w(i) + (h / 4) * m4;\n  endfor\nendfunction\n\n\nfunction [t, w] = rko4(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    k1 = h * f(t(i), w(i));\n    k2 = h * f(t(i) + (h / 2), w(i) + (k1 / 2));\n    k3 = h * f(t(i) + (h / 2), w(i) + (k2 / 2));\n    k4 = h * f(t(i + 1), w(i) + k3);\n    w(i + 1) = w(i) + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n  endfor\nendfunction\n\n\nf = @(t, y) (y - t ^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n[t1, w1] = midpoint(f, a, b, 10, alpha);\n[t2, w2] = modeuler(f, a, b, 10, alpha);\n[t3, w3] = heun(f, a, b, 10, alpha);\n[t4, w4] = rko4(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) ^ 2 - 0.5 * exp(t);\n\nfplot(sln, [0, 2], 'k');\nhold on;\nscatter(t1, w1, 'r');\nscatter(t2, w2, 'g');\nscatter(t3, w3, 'b');\nscatter(t4, w4, 'm');\nlegend('Fungsi eksak', 'Midpoint', 'Modified Euler', 'Heun',\n'Runge-Kutta orde 4');\nlegend(\"location\", \"northwest\");\ntitle('Perbandingan metode Runge-Kutta');\n\n\n\n\ngambar pop up plot"
  },
  {
    "objectID": "module/week-02p2.html",
    "href": "module/week-02p2.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Metode Euler metode paling dasar dalam mencari solusi dari permasalahan nilai awal dari suatu PD. Metode ini dikembangkan dari Teorema Taylor:\nMetode Euler metode paling dasar dalam mencari solusi dari permasalahan nilai awal dari suatu PD. Metode ini dikembangkan dari Teorema Taylor:\n\\[\ny\\left(t_{i+1}\\right)=y\\left(t_i\\right)+\\left(t_{i+1}-t_I\\right) y^{\\prime}\\left(t_i\\right)+\\cdots\n\\]\nMisalkan kita mempunyai suatu persamaan diferensial dengan nilai awal:\n\\[\n\\begin{gathered}\ny^{\\prime}=f(t, y), a \\leq t \\leq b \\\\\ny(a)=\\alpha\n\\end{gathered}\n\\]\nmaka solusi secara numeriknya adalah \\(w_i= y(t_i)\\), dengan:\n\\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+h f\\left(t_i, w_i\\right), \\quad i=1,2, \\ldots, n\n\\end{gathered}\n\\]\ndengan \\(n+1\\in \\mathbb{N}\\) menyatakan banyaknya titik nantinya.\nSolusi kita akan berupa titik yang nantinya dapat menggunakan interpolasi untuk nilai yang tidak dimuat di \\(w_i\\)\nAlgoritma untuk metode Euler adalah sebagai berikut:\n\nfunction [t, w] = euler(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    w(i + 1) = w(i) + h * m1;\n  endfor\nendfunction\n\nDisini, inputnya adalah: - \\(\\mathrm{f}=\\mathrm{E}(t, y)\\) merupakan suatu fungsi, - a dan b berturut-turut batas bawah dan batas atas dari \\(t\\) - \\(\\mathrm{n}\\) merupakan pembagi untuk step size dan \\(\\mathrm{n}+1\\) yang digunakan sebagai banyaknya titik, dan - alpha merupakan nilai awal Sekarang akan kita coba gunakan untuk menyelesaikan suatu PD. Misal diberikan PD sebagai berikut: \\[\n\\begin{aligned}\n& y^{\\prime}=y-t^2+1,0 \\leq t \\leq 2 \\\\\n& y(0)=0.5\n\\end{aligned}\n\\]\nmaka kita dapat mendefinisikan f=@(t, y)\\left(y-t^{\\wedge} 2+1\\right), a=0, b=2, dan alpha \\(=0.5\\) (@ disini menyatakan fungsi anonim yang cara kerjanya mirip dengan fungsi lambda pada Python), sehingga untuk \\(n=10\\), diperoleh kode sebagai berikut:\n\nf = @(t, y) (y-t^2 + 1);\na = 0;\nb = 2;\nn = 10;\nalpha= 0.5;\n[t_euler, w_euler] = euler(f, a, b, n, alpha)\n\nUntuk visualisasinya, kita akan membuat plot dari hasil yang kita peroleh. Sebagai referensi, solusi eksak dari PD tersebut adalah \\(y(t)=(t+1)^2- 0.5 e^t\\)\nKita tambahkan kode berikut pada file:$\n\nsln = @(t) (t + 1)^2 - 0.5 * exp(t);\nfplot(sln, [0, 2], 'b');\nhold on;\nscatter(t_euler, w_euler, 'r');\nlegend('Solusi eksak', 'Metode Euler');\ntitle(\"Metode Euler\")\n\nSaat dijalankan, akan muncul jendela pop-up yang berisi plot yang telah dibuat.\n\n\n\ngambar pop up plot\n\n\nPenjelasan: * sln berisi fungsi referensi kita untuk di-plot dan dibandingkan. * fplot(f, [a, b]) akan menampilkan plot dari suatu fungsi f dengan domain [a, b]. Argumen tambahan ‘b’ memberi warna biru pada plot. * hold on akan menahan plot yang ada agar kita bisa menampilkan banyak plot sekaligus. * scatter(x, y) akan menampilkan x-y scatter plot. * legend memberi legenda pada plot yang telah dibuat. Legenda tersebut dimasukkan berurutan mulai dari plot yang didefinsikan terlebih dahulu * title memberi judul pada plot\n\n\n\n\nMetode midpoint \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} f\\left(t_i, w_i\\right)\\right)\n\\end{gathered}\n\\]\nMetode Euler modifikasi \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+\\frac{h}{2}\\left(f\\left(t_i, w_i\\right)+f\\left(t_{i+1}, w_i+h f\\left(t_i, w_i\\right)\\right)\\right)\n\\end{gathered}\n\\]\nMetode Heun (tidak umum digunakan) \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+\\frac{h}{4}\\left(f\\left(t_i, w_i\\right)+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} f\\left(t_i, w_i\\right)\\right)\\right)\\right)\n\\end{gathered}\n\\]\nMetode Runge-Kutta orde 4 \\[\n\\begin{aligned}\n& w_1=\\alpha \\\\\n& m_1=h f\\left(t_i, w_i\\right) \\\\\n& m_2=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{m_1}{2}\\right) \\\\\n& m_3=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{m_2}{2}\\right) \\\\\n& m_4=h f\\left(t_{i+1}, w_i+m_3\\right) \\\\\n& w_{i+1}=w_i+\\frac{m_1+2 m_2+2 m_3+m_4}{6}\n\\end{aligned}\n\\]\n\nBerikut adalah list algoritmanya.\n\nfunction [t, w] = midpoint(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 2), w(i) + (h / 2) * m1);\n    w(i + 1) = w(i) + h * m2;\n  endfor\nendfunction\n\n\nfunction [t, w] = modeuler(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i + 1), w(i) + h * m1);\n    w(i + 1) = w(i) + h * (m1 + m2) / 2;\n  endfor\nendfunction\n\n\nfunction [t, w] = heun(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 3), w(i) + (h / 3) * m1);\n    m3 = f(t(i) + (2 * h / 3), w(i) + (2 * h / 3) * m2);\n    m4 = m1 + 3 * m3;\n    w(i + 1) = w(i) + (h / 4) * m4;\n  endfor\nendfunction\n\n\nfunction [t, w] = rko4(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    k1 = h * f(t(i), w(i));\n    k2 = h * f(t(i) + (h / 2), w(i) + (k1 / 2));\n    k3 = h * f(t(i) + (h / 2), w(i) + (k2 / 2));\n    k4 = h * f(t(i + 1), w(i) + k3);\n    w(i + 1) = w(i) + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n  endfor\nendfunction\n\n\nf = @(t, y) (y - t ^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n[t1, w1] = midpoint(f, a, b, 10, alpha);\n[t2, w2] = modeuler(f, a, b, 10, alpha);\n[t3, w3] = heun(f, a, b, 10, alpha);\n[t4, w4] = rko4(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) ^ 2 - 0.5 * exp(t);\n\nfplot(sln, [0, 2], 'k');\nhold on;\nscatter(t1, w1, 'r');\nscatter(t2, w2, 'g');\nscatter(t3, w3, 'b');\nscatter(t4, w4, 'm');\nlegend('Fungsi eksak', 'Midpoint', 'Modified Euler', 'Heun',\n'Runge-Kutta orde 4');\nlegend(\"location\", \"northwest\");\ntitle('Perbandingan metode Runge-Kutta');\n\n\n\n\ngambar pop up plot"
  },
  {
    "objectID": "module/week-03.html",
    "href": "module/week-03.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Metode-metode sebelumnya, seperi Euler, Runge-Kutta, dan kawan-kawannya adalah metode jenis one-step, karena kita hanya menggunakan informasi dari satu nilai \\(t_{i}\\). Pada modul berikut akan dijelaskan mengenai metode multistep, dimana kita menggunakan lebih dari satu nilai \\(t_{i}\\) untuk membuat aproksimasi.\nTerdapat dua jenis metode multistep, yaitu:\n\nMultistep eksplisit, dimana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai \\(t\\) sebelumnya.\nMultistep implisit, dimana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai pada \\(t\\) sebelumnya, sekaligus nilai pada \\(t_{i+1}\\) itu sendiri.\n\nUntuk bagian awal, kita hanya akan menggunakan multistep eksplisit, dan multistep implisit akan dijelaskan kemudian menggunakan cara lain.\n\n\nMetode \\(n\\)-step Adams-Bashforth menggunakan \\(n\\) titik sebelumnya untuk mengaproksimasi nilai. Karena metode ini adalah metode multistep, maka \\(n\\) nilai awalnya pun harus diperoleh terlebih dahulu. Misal kita ingin menggunakan metode Adams-Bashforth orde 3 , maka \\(w_{1}, w_{2}\\), dan \\(w_{3}\\) harus ada terlebih dahulu sebelum dilanjutkan ke metode Adams-Bashforth. Nilai-nilai awal tersebut dapat diperoleh dari metode-metode one-step sebelumnya, seperti metode Runge-Kutta, yang akan kita gunakan.\nBerikut rumus untuk metode \\(n\\)-step Adams-Bashforth, masing-masing sesuai dengan jumlah step nya.\n\nTwo-step Adams Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{2}\\left[3 f\\left(t_{i}, w_{i}\\right)-f\\left(t_{i-1}, w_{i-1}\\right)\\right]\n\\end{gathered}\n\\]\n\nThree-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{12}\\left[23 f\\left(t_{i}, w_{i}\\right)-16 f\\left(t_{i-1}, w_{i-1}\\right)+5 f\\left(t_{i-2}, w_{i-2}\\right)\\right]\n\\end{gathered}\n\\]\n\nFour-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3} \\\\\nw_{i+1}=w_{i}+\\frac{h}{24}\\left[55 f\\left(t_{i}, w_{i}\\right)-59 f\\left(t_{i-1}, w_{i-1}\\right)+37 f\\left(t_{i-2}, w_{i-2}\\right)-9 f\\left(t_{i-3}, w_{i-3}\\right)\\right]\n\\end{gathered}\n\\]\n\nFive-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3}, \\quad w_{4}=\\alpha_{4}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{720}\\left[1901 f\\left(t_{i}, w_{i}\\right)-2774 f\\left(t_{i-1}, w_{i-1}\\right)+2616 f\\left(t_{i-2}, w_{i-2}\\right)\\right. \\\\\n\\left.-1274 f\\left(t_{i-3}, w_{i-3}\\right)+251 f\\left(t_{i-4}, w_{i-4}\\right)\\right]\n\\end{gathered}\n\\]\nprogram untuk two-step Adams-Bashforth:\n\n%function_file\nfunction [t, w] = adams2(f, a, b, n, alpha)\n  % Inisiasi variabel awal\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  \n  % Mencari t(2) dan w(2) menggunakan Runge-Kutta orde 4\n  i = 1;\n  t(i + 1) = t(i) + h;\n  m1 = h * f(t(i), w(i));\n  m2 = h * f(t(i) + (h/2), w(i) + (m1/2));\n  m3 = h * f(t(i) + (h/2), w(i) + (m2/2));\n  m4 = h * f(t(i + 1), w(i) + m3);\n  w(i+1) = w(i) + (m1 + 2*m2 + 2*m3 + m4) / 6;\n  \n  % Algoritma utama Adams-Bashforth\n  for i = 2:n\n    t(i + 1) = t(i) + h;\n    k1 = f(t(i), w(i));\n    k2 = f(t(i-1), w(i-1));\n    w(i+1) = w(i) + (h/2) * (3*k1 - k2);\n  endfor\nendfunction\n\nBerikut ini adalah contoh pengerjaaannya dengan menggunakan metode two-step Adams-Bashforth.\n\n%script file\nf = @(t, y) (y - t ^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\nn=20\n[t1, w1] = adams2(f,a,b,n,alpha)\n\n[t1,w1]\n\nsln = @(t) (t + 1) ^ 2 - 0.5 * exp(t);\n\nfplot(sln, [0, 2], 'k');\nhold on;\nscatter(t1, w1, 'r');\n\n\n\n\nSerupa dengan metode adams-bashforth, bedanya persamaan iteratif \\(w_{i+1}\\) belum dalam bentuk yang dapat dihitung langsung (melainkan bentuknya implisit). Berikut ini adalah list persamaan iteratifnya (diambil dari buku burden).\n\nAdams-Moulton Two-Step Implicit Method \\[\n\\begin{aligned}\nw_0 & =\\alpha, \\quad w_1=\\alpha_1, \\\\\nw_{i+1} & =w_i+\\frac{h}{12}\\left[5 f\\left(t_{i+1}, w_{i+1}\\right)+8 f\\left(t_i, w_i\\right)-f\\left(t_{i-1}, w_{i-1}\\right)\\right],\n\\end{aligned}\n\\]\nAdams-Moulton Three-Step Implicit Method\n\n\\[\n\\begin{aligned}\nw_0 & =\\alpha, \\quad w_1=\\alpha_1, \\quad w_2=\\alpha_2, \\\\\nw_{i+1} & =w_i+\\frac{h}{24}\\left[9 f\\left(t_{i+1}, w_{i+1}\\right)+19 f\\left(t_i, w_i\\right)-5 f\\left(t_{i-1}, w_{i-1}\\right)+f\\left(t_{i-2}, w_{i-2}\\right)\\right],\n\\end{aligned}\n\\]\n\nAdams-Moulton Four-Step Implicit Method\n\n\\[\n\\begin{aligned}\nw_0= & \\alpha, \\quad w_1=\\alpha_1, \\quad w_2=\\alpha_2, \\quad w_3=\\alpha_3, \\\\\nw_{i+1}= & w_i+\\frac{h}{720}\\left[251 f\\left(t_{i+1}, w_{i+1}\\right)+646 f\\left(t_i, w_i\\right)\\right. \\\\\n& \\left.-264 f\\left(t_{i-1}, w_{i-1}\\right)+106 f\\left(t_{i-2}, w_{i-2}\\right)-19 f\\left(t_{i-3}, w_{i-3}\\right)\\right],\n\\end{aligned}\n\\]\nBentuk umum program yang akan dihasilkan\n\n%function_file\nfunction [t, w] = adam-moulton-general(f, a, b, n, alpha)\n  [\n    Inisialisai awal ...\n  ]\n  \n  [\n\n    Mencari nilai w_i lainnya yang dibutuhkan dengan rungge kutta jika \n    nilai awal tersebut tidak diberikan dengan runge-kutta\n  ]\n  \n  % Algoritma utama Adams-Bashforth\n\n\n  [\n    Iteratif algoritma adams-moulton\n\n    pada saat mencari $w_{i+1}$ gunakan metode numerik favorit anda.\n  ]\n\nendfunction\n\nTinjau bahwa, jika \\(f\\) linear, kita bisa mencarinya nilai bentuk explisit \\(W_{i+1}\\) dengan mudah. Dengan demikian, kita bisa mengganti metode numerik yang digunakan untuk mencari \\(w_{i+1}\\) dengan metode analitik.\n\n\n\nMenggunakan nilai \\(w_{i+1}\\) yang didapat secara implisit dari metode adams-moulton, kita masukkan ke dalam metode adams-bashforth untuk mengupdate nilai nilai \\(w_{i+1}\\) kembali.\nLihat contoh pada pada sub-chapter berikutnya.\n\n\n\n\n\n\n\n%function_file\nfunction [t,w] = rk4_sys(f, a, b, n, y0)\n  %f :differential equation y_p = f(t,y)\n  %a :initial time\n  %b :final time\n  %n :number of steps\n  %y0 :initial value\n\n  h=(b-a)/n;\n  t=[a:h:b];\n  s= length(y0);\n  w=zeros(s,n+1);\n  w(:,1)=y0;\n\n  for i=1:n\n    k1=f(t(i),w(:,i));\n    k2=f(t(i)+h/2,w(:,i)+h*k1/2);\n    k3=f(t(i)+h/2,w(:,i)+h*k2/2);\n    k4=f(t(i)+h,w(:,i)+h*k3);\n    w(:,i+1)=w(:,i)+h*(k1+2*k2+2*k3+k4)/6;\n\nyang perlu dicatat disini fungsi f merupakan fungsi anonimus yang mengeluarkan vektor hasil evaluasinya.\nberikut ini adalah contoh penggunaan fungsi rk4_sys untuk sistem persamaan differential.\n\\[\n\\begin{aligned}\n& I_1^{\\prime}=f_1\\left(t, I_1, I_2\\right)=-4 I_1+3 I_2+6, \\quad I_1(0)=0 \\\\\n& I_2^{\\prime}=f_2\\left(t, I_1, I_2\\right)=0.6 I_1^{\\prime}-0.2 I_2=-2.4 I_1+1.6 I_2+3.6, \\quad I_2(0)=0 .\n\\end{aligned}\n\\] Persamasalahan berikut akan dikerjakan dengan rk4_sys dengan mengunakan titik awal \\(t_0=0\\) dan \\(t_{n+1}=1\\) dengan \\(n=10\\) partisi.\n\n%script file\nf=@(t, I) [-4 * I(1)+ 3 * I(2)+6 ; -2.4*I(1) + 1.6 * I(2)+3.6] % fungsi\n% perhatikan bahwa  I addalah vektor (hence ada I(1) dan I(2))\ny0=[0;0] % nilai awal\na=0 % titik awal\nb=1 % titik akhir\nn=10 % banyaknya partisi.\n\n[t_sys, w_sys] = rk4_sys(f,a,b,n,y0)\n\ntranspose([t_sys ; w_sys]) %rapikan format\n\nCobalah jalankan kode di atas dan lihat hasilnya. selanjutnya bandingkan hasil dengan jawaban pada buku.\n\n\n\n\n\n% the multi-step second order method Adams-Bashforth-Moulton \n\n%function_file\nfunction [t,w] = abm2_sys(f,a,b,n,y0)\n  h=(b-a)/n;\n  t=[a:h:b];\n  s= length(y0);\n  w=zeros(s,n+1);\n  w(:,1)=y0;\n\n  w_serch= rk4_sys(f,a,b,n,y0);\n\n  w(:,2)= w_serch(:,2);\n\n  wnm1 = f(t(1),y0);\n  wn= f(t(2),y1);\n\n  for i=2:n\n    ws=w(:,i)+h/2*(3*wn-wnm1); % predictor\n    wnp1= f(t(i+1),ws); % predictor\n\n    w(:,i+1)=w(:,i)+h/2*(wn+wnp1); % corrector\n    wnm1=wn;\n    wn=f(t(i),w(:,i)); %corector"
  },
  {
    "objectID": "Tugas/tugas-01.html",
    "href": "Tugas/tugas-01.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Tugas Praktikum 1 PD NUMERIK\nisi disini."
  },
  {
    "objectID": "tugas/tugas-01.html",
    "href": "tugas/tugas-01.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Tugas ini dikerjakan secara individu.\nTerdapat satu (1) soal yang harus dijawab.\nFile yang harus diunggah terdiri dari:\n\n\nbeberapa function file sesuai kebutuhan. Penamaan untuk function file dibebaskan, selama masih relevan dengan isi fungsinya (dilarang menamakan function file “adamsorde5.m” jika isinya adalah metode Runge-Kutta).\nsatu (1) script file untuk jawaban. Penamaannya adalah “soal.m” untuk soal yang diberikan.\nsatu (1) file PDF untuk penjelasan keseluruhan soal. Penjelasan diketik dalam Word atau sejenisnya dengan format penamaan “Penjelasan.pdf”.\n\n\nSemua file disatukan dalam satu file .zip dengan format penamaan:\n\n[Nama][NPM][Kelas SIAK]_Tugas 1_Prak PDNum.zip\nContoh: “Cristiano Ronaldo_2101234567_C_Tugas 1_Prak PDNum.zip”\n\nBatas pengumpulan tugas ini adalah Selasa, 21 Maret 2023, pukul 23.59 WIB.\n\nTugas dikumpulkan melalui gform sesuai dengan kelas masing-masing:\nLink: https://bit.ly/Tugas1PrakPDNum\n*mohon perhatikan waktu pengumpulan yang tertera dan kumpulkan tugas secara tepat waktu.\n\nDilarang melakukan plagiarisme. Jika terdapat mahasisya yang terindikasi melakukan plagiarisme, maka mahasiswa tersebut memperoleh nilai 0 untuk tugas ini.\nApabila ada pertanyaan, harap huibungi CP:\n\nTulus Setiawan (WA/LINE: tlsnew/081213679316) Diberikan suatu initial value problem\n\n\n\n\\[\n\\begin{aligned}\n& y^{\\prime}=\\frac{y^{2}}{1+t}, \\quad 1 \\leq t \\leq 2 \\\\\n& y(1)=-(\\ln 2)^{-1}\n\\end{aligned}\n\\]\nDiketahui solusi eksak dari IVP tersebut adalah:\n\\[\ny(t)=-\\frac{1}{\\ln (t+1)}\n\\]\n\nGunakan tiga metode one-step pilihan Anda untuk mengaproksimasi dan membandingkan solusi dari IVP tersebut menggunakan stepsize \\(h=0.05\\).\nBuatlah grafik perbandingan dari metode tersebut."
  },
  {
    "objectID": "tugas-pd/tugas-01.html",
    "href": "tugas-pd/tugas-01.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Tugas ini dikerjakan secara individu.\nTerdapat satu (1) soal yang harus dijawab.\nFile yang harus diunggah terdiri dari:\n\n\nbeberapa function file sesuai kebutuhan. Penamaan untuk function file dibebaskan, selama masih relevan dengan isi fungsinya (dilarang menamakan function file “adamsorde5.m” jika isinya adalah metode Runge-Kutta).\nsatu (1) script file untuk jawaban. Penamaannya adalah “soal.m” untuk soal yang diberikan.\nsatu (1) file PDF untuk penjelasan keseluruhan soal. Penjelasan diketik dalam Word atau sejenisnya dengan format penamaan “Penjelasan.pdf”.\n\n\nSemua file disatukan dalam satu file .zip dengan format penamaan:\n\n[Nama][NPM][Kelas SIAK]_Tugas 1_Prak PDNum.zip\nContoh: “Cristiano Ronaldo_2101234567_C_Tugas 1_Prak PDNum.zip”\n\nBatas pengumpulan tugas ini adalah Selasa, 21 Maret 2023, pukul 23.59 WIB.\n\nTugas dikumpulkan melalui gform sesuai dengan kelas masing-masing:\nLink: https://bit.ly/Tugas1PrakPDNum\n*mohon perhatikan waktu pengumpulan yang tertera dan kumpulkan tugas secara tepat waktu.\n\nDilarang melakukan plagiarisme. Jika terdapat mahasisya yang terindikasi melakukan plagiarisme, maka mahasiswa tersebut memperoleh nilai 0 untuk tugas ini.\nApabila ada pertanyaan, harap huibungi CP:\n\nTulus Setiawan (WA/LINE: tlsnew/081213679316) Diberikan suatu initial value problem\n\n\n\n\\[\n\\begin{aligned}\n& y^{\\prime}=\\frac{y^{2}}{1+t}, \\quad 1 \\leq t \\leq 2 \\\\\n& y(1)=-(\\ln 2)^{-1}\n\\end{aligned}\n\\]\nDiketahui solusi eksak dari IVP tersebut adalah:\n\\[\ny(t)=-\\frac{1}{\\ln (t+1)}\n\\]\n\nGunakan tiga metode one-step pilihan Anda untuk mengaproksimasi dan membandingkan solusi dari IVP tersebut menggunakan stepsize \\(h=0.05\\).\nBuatlah grafik perbandingan dari metode tersebut."
  },
  {
    "objectID": "tugas-pd/tugas-01.html#petunjuk-pengumpulan-tugas",
    "href": "tugas-pd/tugas-01.html#petunjuk-pengumpulan-tugas",
    "title": "pdnum-2023",
    "section": "Petunjuk Pengumpulan Tugas",
    "text": "Petunjuk Pengumpulan Tugas\n\nTugas ini dikerjakan secara individu.\nTerdapat satu (1) soal yang harus dijawab.\nFile yang harus diunggah terdiri dari:\n\n\nbeberapa function file sesuai kebutuhan. Penamaan untuk function file dibebaskan, selama masih relevan dengan isi fungsinya (dilarang menamakan function file “adamsorde5.m” jika isinya adalah metode Runge-Kutta).\nsatu (1) script file untuk jawaban. Penamaannya adalah “soal.m” untuk soal yang diberikan.\nsatu (1) file PDF untuk penjelasan keseluruhan soal. Penjelasan diketik dalam Word atau sejenisnya dengan format penamaan “Penjelasan.pdf”.\n\n\nSemua file disatukan dalam satu file .zip dengan format penamaan:\n\n[Nama][NPM][Kelas SIAK]_Tugas 1_Prak PDNum.zip\nContoh: “Cristiano Ronaldo_2101234567_C_Tugas 1_Prak PDNum.zip”\n\nBatas pengumpulan tugas ini adalah Selasa, 21 Maret 2023, pukul 23.59 WIB.\n\nTugas dikumpulkan melalui gform sesuai dengan kelas masing-masing:\nLink: https://bit.ly/Tugas1PrakPDNum\n*mohon perhatikan waktu pengumpulan yang tertera dan kumpulkan tugas secara tepat waktu.\n\nDilarang melakukan plagiarisme. Jika terdapat mahasisya yang terindikasi melakukan plagiarisme, maka mahasiswa tersebut memperoleh nilai 0 untuk tugas ini.\nApabila ada pertanyaan, harap huibungi CP:\n\nTulus Setiawan (WA/LINE: tlsnew/081213679316) Diberikan suatu initial value problem"
  },
  {
    "objectID": "tugas-pd/tugas-01.html#soal",
    "href": "tugas-pd/tugas-01.html#soal",
    "title": "pdnum-2023",
    "section": "SOAL",
    "text": "SOAL\n\\[\n\\begin{aligned}\n& y^{\\prime}=\\frac{y^{2}}{1+t}, \\quad 1 \\leq t \\leq 2 \\\\\n& y(1)=-(\\ln 2)^{-1}\n\\end{aligned}\n\\]\nDiketahui solusi eksak dari IVP tersebut adalah:\n\\[\ny(t)=-\\frac{1}{\\ln (t+1)}\n\\]\n\nGunakan tiga metode one-step pilihan Anda untuk mengaproksimasi dan membandingkan solusi dari IVP tersebut menggunakan stepsize \\(h=0.05\\).\nBuatlah grafik perbandingan dari metode tersebut."
  },
  {
    "objectID": "tugas-pd/tugas-03.html",
    "href": "tugas-pd/tugas-03.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Tugas ini dikerjakan secara individu.\nTerdapat satu (1) soal yang harus dijawab.\nFile yang harus diunggah terdiri dari:\n\nbeberapa function file sesuai kebutuhan. Penamaan untuk function file dibebaskan, selama masih relevan dengan isi fungsinya (dilarang menamakan function file “adamsorde5.m” jika isinya adalah metode Runge-Kutta).\nsatu (1) script file untuk jawaban. Penamaannya adalah “soal.m” untuk soal yang diberikan.\nsatu (1) file PDF untuk penjelasan keseluruhan soal. Penjelasan diketik dalam Word atau sejenisnya dengan format penamaan “Penjelasan.pdf”.\n\nSemua file disatukan dalam satu file .zip dengan format penamaan:\n\n[Nama]_[NPM]_[Kelas SIAK]_Tugas 1_Prak PDNum.zip\nContoh: “Cristiano-Ronaldo_2101234567_C_Tugas 1_Prak PDNum.zip”\n\nBatas pengumpulan tugas ini adalah Selasa, 21 April 2023, pukul 23.59 WIB.\n\nTugas dikumpulkan melalui gform sesuai dengan kelas masing-masing:\nLink: [TODO] buat link\n\nDilarang melakukan plagiarisme. Jika terdapat mahasisya yang terindikasi melakukan plagiarisme, maka mahasiswa tersebut memperoleh nilai 0 untuk tugas ini.\nApabila ada yang ingin ditanyakan anda dapat bertanya pada kolom komentar atau, silakan mengontak salah satu kontak berikut:\n\nLINE: Carles_Octavianus (carles)\n\n\n\n\n\n\n\nUbahlah 2 metode persamaan differential numerik (dapat berupa metode single-step ataupun multi-step) favorit (selain runge-kutta tentunya) menjadi metode yang dapat menyelesaikan persamaan differensial.\ngunakan kedua metode tersebut unutk menyelesaikan persamaan differensial berikut:\n\\(y^{\\prime \\prime}-2 y^{\\prime}+y=t e^t-t, \\quad 0 \\leq t \\leq 1, \\quad y(0)=y^{\\prime}(0)=0\\), dengan \\(h=0.1\\) dengan solusi analitiknya: \\(y(t)=\\frac{1}{6} t^3 e^t-t e^t+2 e^t-t-2\\)\ndan Buatlah grafik perbandingan dari metode tersebut."
  }
]