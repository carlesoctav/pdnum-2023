[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "# Timeline\n\npraktikum-1: 1 Maret 2023, presensi [TODO: link]\npraktikum-2: 8 Maret 2023, presensi [TODO: link]\npraktikum-3: 15 Maret 2023, presensi[TODO: link]\nTugas-1 (PDNUM): 22 Maret 2023, tempat pengumpulan: https://bit.ly/Tugas1PrakPDNum\nTugas-2 (PDNUM): 16 April 2023, tempat pengumpulan: https://bit.ly/Tugas2PrakPDNum\nTugas-3 (PDNUM): 16 April 2023, tempat pengumpulan: https://ristek.link/Tugas3PrakPDNum\npraktikum-5 : 3 Mei 2023, presensi bit.ly/PresensiPrak5PDNum"
  },
  {
    "objectID": "module/week-02p2.html",
    "href": "module/week-02p2.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Metode Euler metode paling dasar dalam mencari solusi dari permasalahan nilai awal dari suatu PD. Metode ini dikembangkan dari Teorema Taylor:\nMetode Euler metode paling dasar dalam mencari solusi dari permasalahan nilai awal dari suatu PD. Metode ini dikembangkan dari Teorema Taylor:\n\\[\ny\\left(t_{i+1}\\right)=y\\left(t_i\\right)+\\left(t_{i+1}-t_I\\right) y^{\\prime}\\left(t_i\\right)+\\cdots\n\\]\nMisalkan kita mempunyai suatu persamaan diferensial dengan nilai awal:\n\\[\n\\begin{gathered}\ny^{\\prime}=f(t, y), a \\leq t \\leq b \\\\\ny(a)=\\alpha\n\\end{gathered}\n\\]\nmaka solusi secara numeriknya adalah \\(w_i= y(t_i)\\), dengan:\n\\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+h f\\left(t_i, w_i\\right), \\quad i=1,2, \\ldots, n\n\\end{gathered}\n\\]\ndengan \\(n+1\\in \\mathbb{N}\\) menyatakan banyaknya titik nantinya.\nSolusi kita akan berupa titik yang nantinya dapat menggunakan interpolasi untuk nilai yang tidak dimuat di \\(w_i\\)\nAlgoritma untuk metode Euler adalah sebagai berikut:\n\nfunction [t, w] = euler(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    w(i + 1) = w(i) + h * m1;\n  endfor\nendfunction\n\nDisini, inputnya adalah: - \\(\\mathrm{f}=\\mathrm{E}(t, y)\\) merupakan suatu fungsi, - a dan b berturut-turut batas bawah dan batas atas dari \\(t\\) - \\(\\mathrm{n}\\) merupakan pembagi untuk step size dan \\(\\mathrm{n}+1\\) yang digunakan sebagai banyaknya titik, dan - alpha merupakan nilai awal Sekarang akan kita coba gunakan untuk menyelesaikan suatu PD. Misal diberikan PD sebagai berikut: \\[\n\\begin{aligned}\n& y^{\\prime}=y-t^2+1,0 \\leq t \\leq 2 \\\\\n& y(0)=0.5\n\\end{aligned}\n\\]\nmaka kita dapat mendefinisikan f=@(t, y)\\left(y-t^{\\wedge} 2+1\\right), a=0, b=2, dan alpha \\(=0.5\\) (@ disini menyatakan fungsi anonim yang cara kerjanya mirip dengan fungsi lambda pada Python), sehingga untuk \\(n=10\\), diperoleh kode sebagai berikut:\n\nf = @(t, y) (y-t^2 + 1);\na = 0;\nb = 2;\nn = 10;\nalpha= 0.5;\n[t_euler, w_euler] = euler(f, a, b, n, alpha)\n\nUntuk visualisasinya, kita akan membuat plot dari hasil yang kita peroleh. Sebagai referensi, solusi eksak dari PD tersebut adalah \\(y(t)=(t+1)^2- 0.5 e^t\\)\nKita tambahkan kode berikut pada file:$\n\nsln = @(t) (t + 1)^2 - 0.5 * exp(t);\nfplot(sln, [0, 2], 'b');\nhold on;\nscatter(t_euler, w_euler, 'r');\nlegend('Solusi eksak', 'Metode Euler');\ntitle(\"Metode Euler\")\n\nSaat dijalankan, akan muncul jendela pop-up yang berisi plot yang telah dibuat.\n\n\n\ngambar pop up plot\n\n\nPenjelasan: * sln berisi fungsi referensi kita untuk di-plot dan dibandingkan. * fplot(f, [a, b]) akan menampilkan plot dari suatu fungsi f dengan domain [a, b]. Argumen tambahan ‘b’ memberi warna biru pada plot. * hold on akan menahan plot yang ada agar kita bisa menampilkan banyak plot sekaligus. * scatter(x, y) akan menampilkan x-y scatter plot. * legend memberi legenda pada plot yang telah dibuat. Legenda tersebut dimasukkan berurutan mulai dari plot yang didefinsikan terlebih dahulu * title memberi judul pada plot\n\n\n\n\nMetode midpoint \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{h}{2} f\\left(t_i, w_i\\right)\\right)\n\\end{gathered}\n\\]\nMetode Euler modifikasi \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+\\frac{h}{2}\\left(f\\left(t_i, w_i\\right)+f\\left(t_{i+1}, w_i+h f\\left(t_i, w_i\\right)\\right)\\right)\n\\end{gathered}\n\\]\nMetode Heun (tidak umum digunakan) \\[\n\\begin{gathered}\nw_1=\\alpha \\\\\nw_{i+1}=w_i+\\frac{h}{4}\\left(f\\left(t_i, w_i\\right)+3 f\\left(t_i+\\frac{2 h}{3}, w_i+\\frac{2 h}{3} f\\left(t_i+\\frac{h}{3}, w_i+\\frac{h}{3} f\\left(t_i, w_i\\right)\\right)\\right)\\right)\n\\end{gathered}\n\\]\nMetode Runge-Kutta orde 4 \\[\n\\begin{aligned}\n& w_1=\\alpha \\\\\n& m_1=h f\\left(t_i, w_i\\right) \\\\\n& m_2=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{m_1}{2}\\right) \\\\\n& m_3=h f\\left(t_i+\\frac{h}{2}, w_i+\\frac{m_2}{2}\\right) \\\\\n& m_4=h f\\left(t_{i+1}, w_i+m_3\\right) \\\\\n& w_{i+1}=w_i+\\frac{m_1+2 m_2+2 m_3+m_4}{6}\n\\end{aligned}\n\\]\n\nBerikut adalah list algoritmanya.\n\nfunction [t, w] = midpoint(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 2), w(i) + (h / 2) * m1);\n    w(i + 1) = w(i) + h * m2;\n  endfor\nendfunction\n\n\nfunction [t, w] = modeuler(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i + 1), w(i) + h * m1);\n    w(i + 1) = w(i) + h * (m1 + m2) / 2;\n  endfor\nendfunction\n\n\nfunction [t, w] = heun(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    m1 = f(t(i), w(i));\n    m2 = f(t(i) + (h / 3), w(i) + (h / 3) * m1);\n    m3 = f(t(i) + (2 * h / 3), w(i) + (2 * h / 3) * m2);\n    m4 = m1 + 3 * m3;\n    w(i + 1) = w(i) + (h / 4) * m4;\n  endfor\nendfunction\n\n\nfunction [t, w] = rko4(f, a, b, n, alpha)\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  for i = 1: n\n    t(i + 1) = t(i) + h;\n    k1 = h * f(t(i), w(i));\n    k2 = h * f(t(i) + (h / 2), w(i) + (k1 / 2));\n    k3 = h * f(t(i) + (h / 2), w(i) + (k2 / 2));\n    k4 = h * f(t(i + 1), w(i) + k3);\n    w(i + 1) = w(i) + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n  endfor\nendfunction\n\n\nf = @(t, y) (y - t ^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\n[t1, w1] = midpoint(f, a, b, 10, alpha);\n[t2, w2] = modeuler(f, a, b, 10, alpha);\n[t3, w3] = heun(f, a, b, 10, alpha);\n[t4, w4] = rko4(f, a, b, 10, alpha);\n\nsln = @(t) (t + 1) ^ 2 - 0.5 * exp(t);\n\nfplot(sln, [0, 2], 'k');\nhold on;\nscatter(t1, w1, 'r');\nscatter(t2, w2, 'g');\nscatter(t3, w3, 'b');\nscatter(t4, w4, 'm');\nlegend('Fungsi eksak', 'Midpoint', 'Modified Euler', 'Heun',\n'Runge-Kutta orde 4');\nlegend(\"location\", \"northwest\");\ntitle('Perbandingan metode Runge-Kutta');\n\n\n\n\ngambar pop up plot"
  },
  {
    "objectID": "module/week-03.html",
    "href": "module/week-03.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Metode-metode sebelumnya, seperi Euler, Runge-Kutta, dan kawan-kawannya adalah metode jenis one-step, karena kita hanya menggunakan informasi dari satu nilai \\(t_{i}\\). Pada modul berikut akan dijelaskan mengenai metode multistep, dimana kita menggunakan lebih dari satu nilai \\(t_{i}\\) untuk membuat aproksimasi.\nTerdapat dua jenis metode multistep, yaitu:\n\nMultistep eksplisit, dimana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai \\(t\\) sebelumnya.\nMultistep implisit, dimana kita mengaproksimasi nilai pada \\(t_{i+1}\\) menggunakan nilai pada \\(t\\) sebelumnya, sekaligus nilai pada \\(t_{i+1}\\) itu sendiri.\n\nUntuk bagian awal, kita hanya akan menggunakan multistep eksplisit, dan multistep implisit akan dijelaskan kemudian menggunakan cara lain.\n\n\nMetode \\(n\\)-step Adams-Bashforth menggunakan \\(n\\) titik sebelumnya untuk mengaproksimasi nilai. Karena metode ini adalah metode multistep, maka \\(n\\) nilai awalnya pun harus diperoleh terlebih dahulu. Misal kita ingin menggunakan metode Adams-Bashforth orde 3 , maka \\(w_{1}, w_{2}\\), dan \\(w_{3}\\) harus ada terlebih dahulu sebelum dilanjutkan ke metode Adams-Bashforth. Nilai-nilai awal tersebut dapat diperoleh dari metode-metode one-step sebelumnya, seperti metode Runge-Kutta, yang akan kita gunakan.\nBerikut rumus untuk metode \\(n\\)-step Adams-Bashforth, masing-masing sesuai dengan jumlah step nya.\n\nTwo-step Adams Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{2}\\left[3 f\\left(t_{i}, w_{i}\\right)-f\\left(t_{i-1}, w_{i-1}\\right)\\right]\n\\end{gathered}\n\\]\n\nThree-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{12}\\left[23 f\\left(t_{i}, w_{i}\\right)-16 f\\left(t_{i-1}, w_{i-1}\\right)+5 f\\left(t_{i-2}, w_{i-2}\\right)\\right]\n\\end{gathered}\n\\]\n\nFour-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3} \\\\\nw_{i+1}=w_{i}+\\frac{h}{24}\\left[55 f\\left(t_{i}, w_{i}\\right)-59 f\\left(t_{i-1}, w_{i-1}\\right)+37 f\\left(t_{i-2}, w_{i-2}\\right)-9 f\\left(t_{i-3}, w_{i-3}\\right)\\right]\n\\end{gathered}\n\\]\n\nFive-step Adams-Bashforth\n\n\\[\n\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{1}=\\alpha_{1}, \\quad w_{2}=\\alpha_{2}, \\quad w_{3}=\\alpha_{3}, \\quad w_{4}=\\alpha_{4}, \\\\\nw_{i+1}=w_{i}+\\frac{h}{720}\\left[1901 f\\left(t_{i}, w_{i}\\right)-2774 f\\left(t_{i-1}, w_{i-1}\\right)+2616 f\\left(t_{i-2}, w_{i-2}\\right)\\right. \\\\\n\\left.-1274 f\\left(t_{i-3}, w_{i-3}\\right)+251 f\\left(t_{i-4}, w_{i-4}\\right)\\right]\n\\end{gathered}\n\\]\nprogram untuk two-step Adams-Bashforth:\n\n%function_file\nfunction [t, w] = adams2(f, a, b, n, alpha)\n  % Inisiasi variabel awal\n  h = (b - a) / n;\n  t = zeros(n + 1, 1);\n  w = zeros(n + 1, 1);\n  t(1) = a;\n  w(1) = alpha;\n  \n  % Mencari t(2) dan w(2) menggunakan Runge-Kutta orde 4\n  i = 1;\n  t(i + 1) = t(i) + h;\n  m1 = h * f(t(i), w(i));\n  m2 = h * f(t(i) + (h/2), w(i) + (m1/2));\n  m3 = h * f(t(i) + (h/2), w(i) + (m2/2));\n  m4 = h * f(t(i + 1), w(i) + m3);\n  w(i+1) = w(i) + (m1 + 2*m2 + 2*m3 + m4) / 6;\n  \n  % Algoritma utama Adams-Bashforth\n  for i = 2:n\n    t(i + 1) = t(i) + h;\n    k1 = f(t(i), w(i));\n    k2 = f(t(i-1), w(i-1));\n    w(i+1) = w(i) + (h/2) * (3*k1 - k2);\n  endfor\nendfunction\n\nBerikut ini adalah contoh pengerjaaannya dengan menggunakan metode two-step Adams-Bashforth.\n\n%script file\nf = @(t, y) (y - t ^ 2 + 1);\na = 0;\nb = 2;\nalpha = 0.5;\nn=20\n[t1, w1] = adams2(f,a,b,n,alpha)\n\n[t1,w1]\n\nsln = @(t) (t + 1) ^ 2 - 0.5 * exp(t);\n\nfplot(sln, [0, 2], 'k');\nhold on;\nscatter(t1, w1, 'r');\n\n\n\n\nSerupa dengan metode adams-bashforth, bedanya persamaan iteratif \\(w_{i+1}\\) belum dalam bentuk yang dapat dihitung langsung (melainkan bentuknya implisit). Berikut ini adalah list persamaan iteratifnya (diambil dari buku burden).\n\nAdams-Moulton Two-Step Implicit Method \\[\n\\begin{aligned}\nw_0 & =\\alpha, \\quad w_1=\\alpha_1, \\\\\nw_{i+1} & =w_i+\\frac{h}{12}\\left[5 f\\left(t_{i+1}, w_{i+1}\\right)+8 f\\left(t_i, w_i\\right)-f\\left(t_{i-1}, w_{i-1}\\right)\\right],\n\\end{aligned}\n\\]\nAdams-Moulton Three-Step Implicit Method\n\n\\[\n\\begin{aligned}\nw_0 & =\\alpha, \\quad w_1=\\alpha_1, \\quad w_2=\\alpha_2, \\\\\nw_{i+1} & =w_i+\\frac{h}{24}\\left[9 f\\left(t_{i+1}, w_{i+1}\\right)+19 f\\left(t_i, w_i\\right)-5 f\\left(t_{i-1}, w_{i-1}\\right)+f\\left(t_{i-2}, w_{i-2}\\right)\\right],\n\\end{aligned}\n\\]\n\nAdams-Moulton Four-Step Implicit Method\n\n\\[\n\\begin{aligned}\nw_0= & \\alpha, \\quad w_1=\\alpha_1, \\quad w_2=\\alpha_2, \\quad w_3=\\alpha_3, \\\\\nw_{i+1}= & w_i+\\frac{h}{720}\\left[251 f\\left(t_{i+1}, w_{i+1}\\right)+646 f\\left(t_i, w_i\\right)\\right. \\\\\n& \\left.-264 f\\left(t_{i-1}, w_{i-1}\\right)+106 f\\left(t_{i-2}, w_{i-2}\\right)-19 f\\left(t_{i-3}, w_{i-3}\\right)\\right],\n\\end{aligned}\n\\]\nBentuk umum program yang akan dihasilkan\n\n%function_file\nfunction [t, w] = adam-moulton-general(f, a, b, n, alpha)\n  [\n    Inisialisai awal ...\n  ]\n  \n  [\n\n    Mencari nilai w_i lainnya yang dibutuhkan dengan rungge kutta jika \n    nilai awal tersebut tidak diberikan dengan runge-kutta\n  ]\n  \n  % Algoritma utama Adams-Bashforth\n\n\n  [\n    Iteratif algoritma adams-moulton\n\n    pada saat mencari $w_{i+1}$ gunakan metode numerik favorit anda.\n  ]\n\nendfunction\n\nTinjau bahwa, jika \\(f\\) linear, kita bisa mencarinya nilai bentuk explisit \\(W_{i+1}\\) dengan mudah. Dengan demikian, kita bisa mengganti metode numerik yang digunakan untuk mencari \\(w_{i+1}\\) dengan metode analitik.\n\n\n\nMenggunakan nilai \\(w_{i+1}\\) yang didapat secara implisit dari metode adams-moulton, kita masukkan ke dalam metode adams-bashforth untuk mengupdate nilai nilai \\(w_{i+1}\\) kembali.\nLihat contoh pada pada sub-chapter berikutnya.\n\n\n\n\n\n\n\n%function_file\nfunction [t,w] = rk4_sys(f, a, b, n, y0)\n  %f :differential equation y_p = f(t,y)\n  %a :initial time\n  %b :final time\n  %n :number of steps\n  %y0 :initial value\n\n  h=(b-a)/n;\n  t=[a:h:b];\n  s= length(y0);\n  w=zeros(s,n+1);\n  w(:,1)=y0;\n\n  for i=1:n\n    k1=f(t(i),w(:,i));\n    k2=f(t(i)+h/2,w(:,i)+h*k1/2);\n    k3=f(t(i)+h/2,w(:,i)+h*k2/2);\n    k4=f(t(i)+h,w(:,i)+h*k3);\n    w(:,i+1)=w(:,i)+h*(k1+2*k2+2*k3+k4)/6;\n\nyang perlu dicatat disini fungsi f merupakan fungsi anonimus yang mengeluarkan vektor hasil evaluasinya.\nberikut ini adalah contoh penggunaan fungsi rk4_sys untuk sistem persamaan differential.\n\\[\n\\begin{aligned}\n& I_1^{\\prime}=f_1\\left(t, I_1, I_2\\right)=-4 I_1+3 I_2+6, \\quad I_1(0)=0 \\\\\n& I_2^{\\prime}=f_2\\left(t, I_1, I_2\\right)=0.6 I_1^{\\prime}-0.2 I_2=-2.4 I_1+1.6 I_2+3.6, \\quad I_2(0)=0 .\n\\end{aligned}\n\\] Persamasalahan berikut akan dikerjakan dengan rk4_sys dengan mengunakan titik awal \\(t_0=0\\) dan \\(t_{n+1}=1\\) dengan \\(n=10\\) partisi.\n\n%script file\nf=@(t, I) [-4 * I(1)+ 3 * I(2)+6 ; -2.4*I(1) + 1.6 * I(2)+3.6] % fungsi\n% perhatikan bahwa  I addalah vektor (hence ada I(1) dan I(2))\ny0=[0;0] % nilai awal\na=0 % titik awal\nb=1 % titik akhir\nn=10 % banyaknya partisi.\n\n[t_sys, w_sys] = rk4_sys(f,a,b,n,y0)\n\ntranspose([t_sys ; w_sys]) %rapikan format\n\nCobalah jalankan kode di atas dan lihat hasilnya. selanjutnya bandingkan hasil dengan jawaban pada buku.\n\n\n\n\n\n% the multi-step second order method Adams-Bashforth-Moulton \n\n%function_file\nfunction [t,w] = abm2_sys(f,a,b,n,y0)\n  h=(b-a)/n;\n  t=[a:h:b];\n  s= length(y0);\n  w=zeros(s,n+1);\n  w(:,1)=y0;\n\n  w_serch= rk4_sys(f,a,b,n,y0);\n\n  w(:,2)= w_serch(:,2);\n\n  wnm1 = f(t(1),y0);\n  wn= f(t(2),y1);\n\n  for i=2:n\n    ws=w(:,i)+h/2*(3*wn-wnm1); % predictor\n    wnp1= f(t(i+1),ws); % predictor\n\n    w(:,i+1)=w(:,i)+h/2*(wn+wnp1); % corrector\n    wnm1=wn;\n    wn=f(t(i),w(:,i)); %corector"
  },
  {
    "objectID": "module/week-04.html",
    "href": "module/week-04.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Bentuk umum sistem Persamaan Diferensial:\n\\(u'_1 = f_1(t,u_1,u_2,...,u_m)\\)\n\\(u'_2 = f_2(t,u_1,u_2,...,u_m)\\)\n\\(...\\)\n\\(u'_m = f_m(t,u_1,u_2,...,u_m)\\)\ndimana:\n\\(a \\leq t \\leq b\\)\n\\(u_1(a)=a_1, u_2(a)=a_2, ..., u_m(a)=a_m\\) (initial value)\n\n\n\nPada modul ini, akan dibahas mengenai metode Runge-Kutta untuk menyelesaikan sistem persamaan diferensial. Berikut merupakan code dari metode Runge-Kutta untuk sistem persamaan diferensial pada Octave yang perlu disimpan pada function file.\nfunction [t, w1, w2] = rkfs(f1, f2, a, b, n, alph1, alph2)\n  h = (b - a)/n;\n  t = w1 = w2 = [];\n  t(1) = a;\n  w1(1) = alph1;\n  w2(1) = alph2;\n  for i = 1:n\n    k11 = h * f1(t(i), w1(i), w2(i));\n    k12 = h * f2(t(i), w1(i), w2(i));\n\n    k21 = h * f1((t(i)+(h/2)), (w1(i)+(k11/2)), (w2(i)+(k12/2)));\n    k22 = h * f2((t(i)+(h/2)), (w1(i)+(k11/2)), (w2(i)+(k12/2)));\n\n    k31 = h * f1((t(i)+(h/2)), (w1(i)+(k21/2)), (w2(i)+(k22/2)));\n    k32 = h * f2((t(i)+(h/2)), (w1(i)+(k21/2)), (w2(i)+(k22/2)));\n\n    k41 = h * f1((t(i)+h), (w1(i)+k31), (w2(i)+k32));\n    k42 = h * f2((t(i)+h), (w1(i)+k31), (w2(i)+k32));\n\n    w1(i+1) = w1(i) + (k11 + 2*k21 + 2*k31 + k41)/6;\n    w2(i+1) = w2(i) + (k12 + 2*k22 + 2*k32 + k42)/6;\n    t(i+1) = a + i*h;\n  endfor\nendfunction\n\n\n\n\\(u'_1 = -4u_1+3u_2+6, \\;u_1(0)=0\\)\n\\(u'_2 = -2.4u_1+1.6u_2+3.6, \\;u_2(0)=0\\)\nAkan diuji dengan \\(h=0.1\\) dan \\(0\\leq t \\leq 0.5\\)\nSolusi eksak:\n\\(u_1(t)=-3.375e^{-2t}+1.875e^{-0.4t}+1.5\\)\n\\(u_2(t) = -2.25e^{-2t}+2.25e^{-0.4t}\\)\nBerikut adalah code script file untuk menjalankan function metode Runge-Kutta untuk sistem PD di atas:\nf1 = @(t, y1, y2) (-4*y1 + 3*y2 + 6);\nf2 = @(t, y1, y2) (-2.4*y1 + 1.6*y2 + 3.6);\n\na = 0;\nb = 0.5;\nn = 5;\nalph1 = 0;\nalph2 = 0;\n\n[t, w1, w2] = rkfs(f1, f2, a, b, n, alph1, alph2);\n\nsln1 = @(t) (-3.375*exp(-2*t) + 1.875*exp(-0.4*t) + 1.5);\nsln2 = @(t) (-2.25*exp(-2*t) + 2.25*exp(-0.4*t));\n\nw1ex = w2ex = [];\nfor i = 1:length(t)\n  w1ex(i) = sln1(t(i));\n  w2ex(i) = sln2(t(i));\nendfor\n\n[t', w1', w2', w1ex', w2ex']\n\nhold on;\nfplot(sln1, [0, 0.5], 'r');\nfplot(sln2, [0, 0.5], 'b');\nscatter(t, w1, 'r');\nscatter(t, w2, 'b');\nlegend('u1', 'u2');\nlegend('location', 'northwest');\nJika kita run script file tersebut, maka program akan mengeluarkan dua macam output, yaitu tabel serta plot perbandingan solusi eksak dan aproksimasi seperti di bawah ini:\n\n\n\nimage.png\n\n\n\n\n\nimage-3.png\n\n\n\n\n\n\n\n\nLinear Shooting merupakan metode untuk menyelesaikan masalah PD berbentuk:\n\\(-y'' + p(x)y' + q(x)y + r(x) = 0, \\;a\\leq x\\leq b\\)\n\\(y(a)=\\alpha, \\;y(b)=\\beta\\)\n\n\n\nfunction [x_i, w_1i, w_2i] = linshoot(p, q, r, a, b, n, alpha, beta)\n  h = (b - a)/n;\n  u = [alpha ; 0];\n  v = [0 ; 1];\n  x_i = w_1i = w_2i = [];\n  for i = 1:n\n    x = a + (i-1)*h;\n\n    k_11 = h * u(2,i);\n    k_12 = h * (p(x)*u(2,i) + q(x)*u(1,i) + r(x));\n\n    k_21 = h * (u(2,i)+(k_12/2));\n    k_22 = h * (p(x+(h/2))*(u(2,i)+(k_12/2)) + q(x+(h/2))*(u(1,i)+(k_11/2)) + r(x+(h/2)));\n\n    k_31 = h * (u(2,i)+(k_22/2));\n    k_32 = h * (p(x+(h/2))*(u(2,i)+(k_22/2)) + q(x+(h/2))*(u(1,i)+(k_21/2)) + r(x+(h/2)));\n\n    k_41 = h * (u(2,i)+k_32);\n    k_42 = h * (p(x+h)*(u(2,i)+k_32) + q(x+h)*(u(1,i)+k_31) + r(x+h));\n\n    u(1,i+1) = u(1,i) + ((k_11 + 2*k_21 + 2*k_31 + k_41)/6);\n    u(2,i+1) = u(2,i) + ((k_12 + 2*k_22 + 2*k_32 + k_42)/6);\n\n    kp_11 = h * v(2,i);\n    kp_12 = h * (p(x)*v(2,i) + q(x)*v(1,i));\n\n    kp_21 = h * (v(2,i) + (kp_12/2));\n    kp_22 = h * (p(x+(h/2))*(v(2,i)+(kp_12/2)) + q(x+(h/2))*(v(1,i)+(kp_11/2)));\n\n    kp_31 = h * (v(2,i)+(kp_22/2));\n    kp_32 = h * (p(x+(h/2))*(v(2,i)+(kp_22/2)) + q(x+(h/2))*(v(1,i)+(kp_21/2)));\n\n    kp_41 = h * (v(2,i)+kp_32);\n    kp_42 = h * (p(x+h)*(v(2,i)+kp_32) + q(x+h)*(v(1,i)+kp_31));\n\n    v(1,i+1) = v(1,i) + (kp_11 + 2*kp_21 + 2*kp_31 + kp_41)/6;\n    v(2,i+1) = v(2,i) + (kp_12 + 2*kp_22 + 2*kp_32 + kp_42)/6;\n  endfor\n\n  w = [alpha ; ((beta - u(1,(n+1))) / v(1,(n+1)))];\n  x_i(1) = a;\n  w_1i(1) = w(1,1);\n  w_2i(1) = w(2,1);\n\n  for i = 2:(n+1)\n    W1 = u(1,i) + w(2,1)*v(1,i);\n    W2 = u(2,i) + w(2,1)*v(2,i);\n    x = a + (i-1)*h;\n    x_i(i) = x;\n    w_1i(i) = W1;\n    w_2i(i) = W2;\n  endfor\nendfunction\n\n\n\n\\(y'' = -\\frac{2}{x}y' + \\frac{2}{x^2}y + \\frac{\\sin(\\ln(x))}{x^2}, \\; 1\\leq x\\leq 2\\)\n\\(y(1)=1,\\; y(2)=2\\)\ndengan \\(n=10\\)\ndan solusi eksak:\n\\(y=c_1x+\\frac{c_2}{x^2} - \\frac{3}{10}\\sin(\\ln(x))-\\frac{1}{10}cos(\\ln(x))\\)\n\\(c_2 = \\frac{1}{70}(8-12\\sin(\\ln(2)) - 4\\cos(\\ln(2)))\\)\n\\(c_1 = \\frac{11}{10}-c_2\\)\nBerikut code script file untuk permasalahan di atas menggunakan metode linear shooting:\np = @(x) (-2*(x^(-1)));\nq = @(x) (2*(x^(-2)));\nr = @(x) (sin(log(x))*(x^(-2)));\na = 1;\nb = 2;\nalph = 1;\nbet = 2;\n\n[xi, w1i, w2i] = linshoot(p, q, r, a, b, 10, alph, bet);\n\nc2 = (8-12*sin(log(2)) - 4*cos(log(2)))/70;\nc1 = (11/10) - c2;\nsln = @(x) (c1*x + (c2*x^(-2)) - (3/10)*sin(log(x)) - (1/10)*cos(log(x)));\nw = [];\nfor i = 1:length(xi)\n  w(i) = sln(xi(i));\nendfor\n\n[xi', w1i', w']\n\nhold on;\nfplot(sln, [1,2], 'k');\nscatter(xi, w1i, '-r');\nlegend('Eksak', 'Aproksimasi');\nlegend('location', 'northwest');\nJika kita run script file tersebut, maka program akan mengeluarkan dua macam output, yaitu tabel serta plot perbandingan solusi eksak dan aproksimasi seperti di bawah ini:\n\n\n\nimage.png\n\n\n\n\n\nimage-2.png\n\n\n\n\n\n\n\n\nNonlinear Shooting digunakan untuk menyelesaikan masalah PD berbentuk:\n\\(y'' = f(x, y, y'), \\; a\\leq x \\leq b\\)\n\\(y(a)=\\alpha, \\; y(b)=\\beta\\)\ndimana, \\(f\\) merupakan fungsi nonlinear\n\n\n\nfunction [x_i, w_1i, w_2i] = nonlinshoot(f, fy, fyp, a, b, n, alpha, beta, m, tol)  % m adalah maksimum iterasi\n  h = (b - a)/n;\n  k = 1;\n  tk = (beta - alpha)/(b - a);\n  x_i = w_1i = w_2i = [];\n  while k <= m\n    w = [alpha;tk];\n    u = [0,1];\n    for i = 1:n\n      x = a + (i-1)*h;\n\n      k_11 = h*w(2,i);\n      k_12 = h*f(x, w(1,i), w(2,i));\n\n      k_21 = h*(w(2,i)+(k_12/2));\n      k_22 = h*f((x+(h/2)), (w(1,i)+(k_11/2)), (w(2,i)+(k_12/2)));\n\n      k_31 = h*(w(2,i)+(k_22/2));\n      k_32 = h*f((x+(h/2)), (w(1,i)+(k_21/2)), (w(2,i)+(k_22/2)));\n\n      k_41 = h*(w(2,i)+k_32);\n      k_42 = h*f((x+h), (w(1,i)+k_31), (w(2,i)+k_32));\n\n      w(1,i+1) = w(1,i) + ((k_11 + 2*k_21 + 2*k_31 + k_41)/6);\n      w(2,i+1) = w(2,i) + ((k_12 + 2*k_22 + 2*k_32 + k_42)/6);\n\n      kp_11 = h*u(2);\n      kp_12 = h*(fy(x, w(1,i), w(2,i))*u(1) + fyp(x, w(1,i), w(2,i))*u(2));\n\n      kp_21 = h*(u(2) + (kp_12/2));\n      kp_22 = h*(fy((x+(h/2)), w(1,i), w(2,i))*u(1) + fyp((x+(h/2)), w(1,i), w(2,i))*(u(2) + (kp_12/2)));\n\n      kp_31 = h*(u(2)+(kp_22/2));\n      kp_32 = h*(fy((x+(h/2)), w(1,i), w(2,i))*(u(1) + (kp_21/2)) + fyp((x+(h/2)), w(1,i), w(2,i))*(u(2) + (kp_22/2)));\n\n      kp_41 = h*(u(2)+kp_32);\n      kp_42 = h*(fy((x+h), w(1,i), w(2,i))*(u(1)+kp_31) + fyp((x+h), w(1,i), w(2,i))*(u(2) + kp_32));\n\n      u(1) = u(1) + (kp_11 + 2*kp_21 + 2*kp_31 + kp_41)/6;\n      u(2) = u(2) + (kp_12 + 2*kp_22 + 2*kp_32 + kp_42)/6;\n    endfor\n\n  if abs(w(1,n+1) - beta) <= tol       % jika sudah mencapai batas toleransi maka program berhenti\n    for i = 1:(n+1)\n      x = a+(i-1)*h;\n      x_i(i) = x;\n      w_1i(i) = w(1,i);\n      w_2i(i) = w(2,i);\n    endfor\n    return\n  endif\n  tk = tk-((w(1,n+1) - beta)/u(1));\n  k = k + 1;\n  endwhile\n  disp('max iteration')\nendfunction\n\n\n\n\\(y'' = \\frac{1}{8}(32+2x^3-yy'), \\; 1\\leq x \\leq 3\\)\n\\(y(1) = 17, \\; y(3)=43/3\\)\ndengan \\(n=20\\), \\(m=10\\), dan toleransi \\(=10^{-5}\\)\ndan solusi eksak:\n\\(y(x)=x^2 + \\frac{16}{x}\\)\nBerikut code script file untuk permasalahan di atas menggunakan metode linear shooting:\nf = @(x, y, yp) ((1/8)*(32 + 2*x^3 - y*yp));\nfy = @(x, y, yp) (-yp/8);\nfyp = @(x, y, yp) (-y/8);\na = 1;\nb = 3;\nn = 20;\nalph = 17;\nbet = 43/3;\nm = 10;\ntol = 10^(-5);\n\n[xi, w1i, w2i] = nonlinshoot(f, fy, fyp, a, b, n, alph, bet, m, tol);\n\nsln = @(x) ((x^2) + (16/x));\nw = [];\nfor i = 1:length(xi)\n  w(i) = sln(xi(i));\nendfor\n\n[xi', w1i', w']\n\nhold on;\nfplot(sln, [1,3], 'k');\nscatter(xi, w1i, 'r');\nlegend('Eksak', 'Aproksimasi');\nJika kita run script file tersebut, maka program akan mengeluarkan dua macam output, yaitu tabel serta plot perbandingan solusi eksak dan aproksimasi seperti di bawah ini:\n\n\n\nimage.png\n\n\n\n\n\nimage-2.png"
  },
  {
    "objectID": "module/week-05.html",
    "href": "module/week-05.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Week-05 (Finite Difference Methods)\nyang akan dibahas - Metode Beda Hingga untuk Masalah Linear\n\nMetode Beda Hingga untuk Masalah Nonlinear\n\nMetode ini digunakan untuk mengaproksimasi masalah linear dalam bentuk:\n\\[\\begin{gathered}\ny^{\\prime \\prime}=p(x) y^{\\prime}+q(x) y+r(x), \\quad a \\leq x \\leq b \\\\\ny(a)=\\alpha, y(b)=\\beta\n\\end{gathered}\\]\n\\[\\begin{gathered}\nw_{0}=\\alpha, \\quad w_{n+1}=\\beta \\\\\n-\\left(1+\\frac{h}{2} p\\left(x_{i}\\right)\\right) w_{i-1}+\\left(2+h^{2} q\\left(x_{i}\\right)\\right) w_{i}-\\left(1-\\frac{h}{2} p\\left(x_{i}\\right)\\right) w_{i+1}=-h^{2} r\\left(x_{i}\\right)\n\\end{gathered}\\]\nBentuk tersebut dapat dibuat sebagai suatu SPL:\n\\[\nA \\mathbf{w}=\\mathbf{b}\n\\]\n\n\\(\\mathbf{w}=\\left[\\begin{array}{c}w_{1} \\\\ w_{2} \\\\ \\vdots \\\\ w_{N-1} \\\\ w_{N}\\end{array}\\right], \\quad\\) and \\(\\quad \\mathbf{b}=\\left[\\begin{array}{c}-h^{2} r\\left(x_{1}\\right)+\\left(1+\\frac{h}{2} p\\left(x_{1}\\right)\\right) w_{0} \\\\ -h^{2} r\\left(x_{2}\\right) \\\\ \\vdots \\\\ -h^{2} r\\left(x_{N-1}\\right) \\\\ -h^{2} r\\left(x_{N}\\right)+\\left(1-\\frac{h}{2} p\\left(x_{N}\\right)\\right) w_{N+1}\\end{array}\\right]\\).\nSPL tersebut akan diselesaikan dengan metode faktorisasi Crout (lihat algoritma 6.7). (basicly ini nyari inverse A secara linear, makanya runtime dari algortima ini adalah \\(O(n)\\))\nAlgoritma dari metode beda hingga linear:\nfunction [xt,w]=linfdm(p,q,r,a_boundary,b_boundary,alpha,beta,n)\n  h=(b_boundary-a_boundary)/(n+1); %stepsize\n  a=zeros(n,1); %diagonal sistem persamaannya\n  b=zeros(n,1); % right diagonal sistem persamaannya\n  c=zeros(n,1); %left diagonal sistem persamaannya\n  d=zeros(n,1); %vektor b (Ay=b) pada sistem persamaannya\n  l=zeros(n,1); % main diagonal of lower triangle matrix\n  u=zeros(n,1); %right diagonal of upper triangle matrix\n  z= zeros(n,1); %solution of Lz=b\n  w=zeros(n+1,1); %solusi aproksimasi dengan linear fdm\n  xt=[a_boundary:h:b_boundary]; %mesh_point\n  x=a_boundary+h;\n\n  %konstruksi matrix tridiagonalnya\n  a(1)=2+(h^2)*q(x);\n  b(1)= -1+(h/2)*p(x);\n  d(1)=-h^2*r(x) +(1+(h/2)*p(x))*alpha;\n\n  for i = 2:n-1\n    x= a_boundary+i*h;\n    a(i)=2+h^2*q(x); %diagonal\n    b(i)=-1+(h/2)*p(x);\n    c(i)=-1-(h/2)*p(x);\n    d(i)=-h^2*r(x);\n  endfor\n\n  x=b_boundary-h;\n  a(n)=2+h^2*q(x);\n  c(n)=-1-(h/2)*p(x);\n  d(n)=-h^2*r(x)+(1-(h/2)*p(x))*beta;\n\n  %matriks tridiagonalnya sudah didapatkan,\n  %akan diselesaikan dengan LU Decomposition (crout factorization)\n\n  l(1)= a(1);\n  u(1)=b(1)/a(1);\n  z(1)=d(1)/l(1);\n\n  for i= 2:n-1\n    l(i)=a(i)-c(i)*u(i-1);\n    u(i)=b(i)/l(i);\n    z(i)=(d(i)-c(i)*z(i-1))/l(i);\n\n  endfor\n\n  l(n)=a(n)-c(n)*u(n-1);\n  z(n)=(d(n)-c(n)*z(n-1))/l(n);\n\n  %konstruksi akhir w-nya\n  w(n+1)=beta;\n  w(n)=z(n);\n  for i = n-1:-1:1\n    w(i)=z(i)-u(i)*w(i+1);\n  endfor\n\n  w=[alpha;w];\n  xt=transpose(xt);\n\nendfunction\nAkan kita uji dengan masalah syarat batas:\n\\[\n\\begin{aligned}\ny^{\\prime \\prime} & =-\\frac{4}{x} y^{\\prime}-\\frac{2}{x^2} y+\\frac{2 \\ln x}{x^2}, \\quad 1 \\leq x \\leq 2 \\\\\ny(1) & =\\frac{1}{2}, \\quad y(2)=\\ln 2\n\\end{aligned}\n\\] Solusi eksak: \\[\ny(x)=\\frac{4}{x}-\\frac{2}{x^2}+\\ln x-\\frac{3}{2}\n\\]\np= @(x) (-4/x); %function p(x)\nq= @(x) (-2/x^2);%function q(x)\nr=@(x) 2*log(x)/(x^2); %function r(x)\na_boundary=1; %batas kiri domain\nb_boundary=2; %batas kanan domain\nn=19; %banyaknya partisi (agar h=0.05 pilih n=19)\nalpha=0.5; %y(a)=alpha\nbeta=log(2); %y(b)=beta\n[x_grid,w]=linfdm(p,q,r,a_boundary,b_boundary,alpha,beta,n) %memangil fungsinya\n\nf_anal=@(x)4./x -2./(x.^2) +log(x)-1.5;\nsol_anal=f_anal(x_grid)\nerror=abs(sol_anal-w);\n\n[x_grid,w,sol_anal,error]\n\n\n%bikint tabel dan grafiknya :D\n\nfplot(f_anal, [a_boundary,b_boundary],'b')\nhold on;\nscatter(x_grid,w,'r')\nlegend('solusi analitik', 'solusi linear FDM');\nlegend(\"location\", \"northwest\");\nMetode ini digunakan untuk mengaproksimasi masalah linear dalam bentuk:\n\\[\n\\begin{gathered}\ny^{\\prime \\prime}=f\\left(x, y, y^{\\prime}\\right), \\quad a \\leq x \\leq b \\\\\ny(a)=\\alpha, y(b)=\\beta\n\\end{gathered}\n\\]\nAproksimasi menggunakan metode ini serupa dengan saat menggunakan metode beda hingga linear, dengan perbedaan kita juga menambahkan metode Newton dalam penyelesaiannya.\nAlgoritma dari metode beda hingga nonlinear:\nfunction [t_grid,w]=nonlinear_FDM_naive(f,f_y,f_yprime,a,b,n,alpha,beta,max_iter,TOL)\n  h=(b-a)/(n+1); %sepsize\n  w=zeros(n,1); %vektor solusi aproksimasi\n  t_grid=[a:h:b]; %mesh_poitnya\n  J=zeros(n,n); %matriks jacobian\n  F=zeros(n,1); %vektor fungsi  F=(f_1,f_2,...,f_n) yang dievaluasi di x_k\n\n  for i=1:n %inisialisasi solusi awal\n    w(i)=alpha+i*(beta-alpha)/(b-a)*h;\n  endfor\n  k=1;\n  while k<=max_iter %lakukan iterasi jika masih belum didapat kriteria stopnya\n\n    %solve nonlinear sistem tersebut dengan metode newton\n    x=a+h;\n    %kontruksi matriks Jacobian, dan vektor F-nya\n    t=(w(2)-alpha)/(2*h);\n    J(1,1)=2+h^2*f_y(x,w(1),t); %main diagoanal\n    J(1,2)=-1+(h/2)*f_yprime(x,w(1),t); %right diagonal\n    F(1)=(2*w(1)-w(2)-alpha+h^2*f(x,w(1),t));\n    for i =2:n-1\n      x=a+i*h;\n      t=(w(i+1)-w(i-1))/(2*h);\n      J(i,i)=2+h^2*f_y(x,w(i),t); %main diagoanal\n      J(i,i+1)=-1+(h/2)*f_yprime(x,w(i),t); %main diagoanal\n      J(i,i-1)=-1-(h/2)*f_yprime(x,w(i),t); %left diagoanal\n      F(i)=(2*w(i)-w(i+1)-w(i-1)+h^2*f(x,w(i),t));\n    endfor\n     x=b-h;\n     t=(beta-w(n-1))/(2*h);\n     J(n,n)=2+h^2*f_y(x,w(n),t); %main diagonal\n     J(n,n-1)=-1-(h/2)*f_yprime(x,w(n),t); %right diagonal\n     F(n)=(2*w(n)-w(n-1)-beta+h^2*f(x,w(n),t));\n\n\n\n    v=inverse(J)*F; %vector v adalah product dari J^-1 F\n    w= w-v; % lakukan update nilai pada w\n\n    if norm(v,2)<= TOL %kriteria stop jika norm(v)<=toleransinya\n      break;\n     else\n        k=k+1; %jika belum memenuhi kriteria stop terus lanjut iterasinya (memperbaiki nilai w)\n    endif\n  endwhile\n  w=[alpha ; w ; beta]; %konstruksi akhir w\n  t_grid=transpose(t_grid); % %transpose meshpoint\n  % untuk konsistensi dimensi saja\n\nendfunction\n\nGunakan metode beda hingga nonlinear dengan \\(h=0.1\\) dan toleransi \\(10^{-4}\\) untuk mengaproksimasi BVP berikut: \\[\n\\begin{aligned}\ny^{\\prime \\prime} & =y^{\\prime}+2(y-\\ln x)^3-\\frac{1}{x}, \\quad 2 \\leq x \\leq 3 \\\\\ny(2) & =\\frac{1}{2}+\\ln 2, \\quad y(3)=\\frac{1}{3}+\\ln 3\n\\end{aligned}\n\\] Solusi eksak: \\[\ny(x)=\\frac{1}{x}+\\ln x\n\\]\n\nf=@(x,y,yp) yp+2*(y-log(x))^3-1/x ; %fungsi f pada y=f(x,y,y')\nf_y=@(x,y,yp) 6*(y-log(x))^2; %turunan fungsi f terhadap y\nf_yp=@(x,y,yp) 1; %turunan fungsi f terhadap yprime\na=2; %left boundary\nb=3; %right boundary\nalpha=0.5+log(2); %y(a)\nbeta=1/3+ log(3); %y(b)\nn=9; %banyaknya partisi (pilih n=9 sehingga h=0.1)\nmaxiter=30; %masksimal iterasi newton methodnya\nTOL=10^(-4); %toleransi nilai (untuk kriteria stop)\n\n%memanggil fungsi nonlinear_FDM_naive\n[x_grid,w]=nonlinear_FDM_naive(f,f_y,f_yp,a,b,n,alpha,beta,maxiter,TOL)\nf_anal= @(x) 1./x +log(x); %sol analitik\n\n%membuat grafiknya\nfplot(f_anal, [a,b],'b')\nhold on;\nscatter(x_grid,w,'r')\nlegend('solusi analitik', 'solusi linear FDM');\nlegend(\"location\", \"northwest\");\n\n\n\n\n%membuat tabel saja.\n\nsol_anal=f_anal(x_grid); %sol analitik di meshpoint\nerror=abs(w-sol_anal); %error\n[x_grid,w,sol_anal,error]"
  },
  {
    "objectID": "tugas-pd/tugas-01.html",
    "href": "tugas-pd/tugas-01.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Tugas ini dikerjakan secara individu.\nTerdapat satu (1) soal yang harus dijawab.\nFile yang harus diunggah terdiri dari:\n\n\nbeberapa function file sesuai kebutuhan. Penamaan untuk function file dibebaskan, selama masih relevan dengan isi fungsinya (dilarang menamakan function file “adamsorde5.m” jika isinya adalah metode Runge-Kutta).\nsatu (1) script file untuk jawaban. Penamaannya adalah “soal.m” untuk soal yang diberikan.\nsatu (1) file PDF untuk penjelasan keseluruhan soal. Penjelasan diketik dalam Word atau sejenisnya dengan format penamaan “Penjelasan.pdf”.\n\n\nSemua file disatukan dalam satu file .zip dengan format penamaan:\n\n[Nama][NPM][Kelas SIAK]_Tugas 1_Prak PDNum.zip\nContoh: “Cristiano Ronaldo_2101234567_C_Tugas 1_Prak PDNum.zip”\n\nBatas pengumpulan tugas ini adalah Selasa, 21 Maret 2023, pukul 23.59 WIB.\n\nTugas dikumpulkan melalui gform sesuai dengan kelas masing-masing:\nLink: https://bit.ly/Tugas1PrakPDNum\n*mohon perhatikan waktu pengumpulan yang tertera dan kumpulkan tugas secara tepat waktu.\n\nDilarang melakukan plagiarisme. Jika terdapat mahasisya yang terindikasi melakukan plagiarisme, maka mahasiswa tersebut memperoleh nilai 0 untuk tugas ini.\nApabila ada pertanyaan, harap huibungi CP:\n\nTulus Setiawan (WA/LINE: tlsnew/081213679316) Diberikan suatu initial value problem\n\n\n\n\\[\n\\begin{aligned}\n& y^{\\prime}=\\frac{y^{2}}{1+t}, \\quad 1 \\leq t \\leq 2 \\\\\n& y(1)=-(\\ln 2)^{-1}\n\\end{aligned}\n\\]\nDiketahui solusi eksak dari IVP tersebut adalah:\n\\[\ny(t)=-\\frac{1}{\\ln (t+1)}\n\\]\n\nGunakan tiga metode one-step pilihan Anda untuk mengaproksimasi dan membandingkan solusi dari IVP tersebut menggunakan stepsize \\(h=0.05\\).\nBuatlah grafik perbandingan dari metode tersebut."
  },
  {
    "objectID": "tugas-pd/tugas-02.html",
    "href": "tugas-pd/tugas-02.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Tugas ini dikerjakan secara individu.\nTerdapat satu (1) soal yang harus dijawab.\nFile yang harus diunggah terdiri dari:\n\nbeberapa function file sesuai kebutuhan. Penamaan untuk function file dibebaskan, selama masih relevan dengan isi fungsinya (dilarang menamakan function file “adamsorde5.m” jika isinya adalah metode Runge-Kutta).\nsatu (1) script file untuk jawaban. Penamaannya adalah “soal.m” untuk soal yang diberikan.\nsatu (1) file PDF untuk penjelasan keseluruhan soal. Penjelasan diketik dalam Word atau sejenisnya dengan format penamaan “Penjelasan.pdf”.\n\nSemua file disatukan dalam satu file .zip dengan format penamaan:\n[Nama]_[NPM]_[Kelas SIAK]_Tugas 2_Prak PDNum.zip\nContoh: “Cristiano-Ronaldo_2101234567_C_Tugas 2_Prak PDNum.zip”\nBatas pengumpulan tugas ini adalah Minggu, 16 April 2023, pukul 23.59 WIB.\nTugas dikumpulkan melalui gform sesuai dengan kelas masing-masing:\nLink: https://bit.ly/Tugas2PrakPDNum (akses menggunakan akun @sci atau @ui)\nDilarang melakukan plagiarisme. Jika terdapat mahasisya yang terindikasi melakukan plagiarisme, maka mahasiswa tersebut memperoleh nilai 0 untuk tugas ini.\nApabila ada yang ingin ditanyakan anda dapat bertanya pada kolom komentar atau, silakan mengontak salah satu kontak berikut:\n\nLINE: iamjustin10 (Justin)\n\n\n\n\n\nArthur adalah seorang pelajar yang menyukai matematika dan pemrograman. Suatu hari, saat Arthur sedang membaca kitab Burden, dia menemukan algoritma Adams predictor-corrector dan menyadari jika cara kerja dari metode tersebut merupakan gabungan dari metode one-step Runge-Kutta orde 4, metode multistep eksplisit Adams-Bashforth 4-step, dan metode multistep implisit Adams-Moulton 3-step.\nArthur penasaran apakah metode predictor-corrector ini bisa dibuat dengan metode yang berbeda dari jenis yang sama. Dia pun mencoba mengubah metode multistep eksplisit dan implisitnya dengan Adams-Bashforth 5-step dan Adams-Moulton 4-step, dengan harapan aproksimasinya akan lebih akurat.\nBantulah Arthur dalam membuat algoritma dari metode buatannya, dan bandingkan dengan metode Adams predictor-corrector sebelumnya. Ujilah menggunakan IVP:\n\\(y^{\\prime}=y-t^2+1,\\; 0\\leq t\\leq2,\\; y(0)=0.5\\)\ndengan stepsize \\(h=0.1\\), jika diketahui solusi eksak dari IVP tersebut adalah\n\\(y(t)=(t+1)^2-0.5 e^t\\)"
  },
  {
    "objectID": "tugas-pd/tugas-03.html",
    "href": "tugas-pd/tugas-03.html",
    "title": "pdnum-2023",
    "section": "",
    "text": "Tugas ini dikerjakan secara individu.\nTerdapat satu (1) soal yang harus dijawab.\nFile yang harus diunggah terdiri dari:\n\nbeberapa function file sesuai kebutuhan. Penamaan untuk function file dibebaskan, selama masih relevan dengan isi fungsinya (dilarang menamakan function file “adamsorde5.m” jika isinya adalah metode Runge-Kutta).\nsatu (1) script file untuk jawaban. Penamaannya adalah “soal.m” untuk soal yang diberikan.\nsatu (1) file PDF untuk penjelasan keseluruhan soal. Penjelasan diketik dalam Word atau sejenisnya dengan format penamaan “Penjelasan.pdf”.\n\nSemua file disatukan dalam satu file .zip dengan format penamaan:\n\n[Nama]_[NPM]_[Kelas SIAK]_Tugas 1_Prak PDNum.zip\nContoh: “Cristiano-Ronaldo_2101234567_C_Tugas 1_Prak PDNum.zip”\n\nBatas pengumpulan tugas ini adalah 16 April 2023, pukul 23.59 WIB.\n\nTugas dikumpulkan melalui gform sesuai dengan kelas masing-masing:\nLink: ristek.link/Tugas3PrakPDNum\n\nDilarang melakukan plagiarisme. Jika terdapat mahasisya yang terindikasi melakukan plagiarisme, maka mahasiswa tersebut memperoleh nilai 0 untuk tugas ini.\nApabila ada yang ingin ditanyakan anda dapat bertanya pada kolom komentar atau, silakan mengontak salah satu kontak berikut:\n\nLINE: Carles_Octavianus (carles)\n\n\n\n\n\n\n\nUbahlah 2 metode persamaan differential numerik (dapat berupa metode single-step ataupun multi-step) favorit (selain runge-kutta tentunya) menjadi metode yang dapat menyelesaikan sistem persamaan differensial.\ngunakan kedua metode tersebut unutk menyelesaikan persamaan differensial berikut:\n\\(y^{\\prime \\prime}-2 y^{\\prime}+y=t e^t-t, \\quad 0 \\leq t \\leq 1, \\quad y(0)=y^{\\prime}(0)=0\\), dengan \\(h=0.1\\) dengan solusi analitiknya: \\(y(t)=\\frac{1}{6} t^3 e^t-t e^t+2 e^t-t-2\\)\ndan Buatlah grafik perbandingan dari metode tersebut."
  }
]